{"./":{"url":"./","title":"简介","keywords":"","body":"smart-doc 概述 smart-doc在业内率先提出基于JAVA泛型定义推导的理念， 完全基于接口源码来分析生成接口文档，不采用任何注解侵入到业务代码中。 你只需要按照java-doc标准编写注释， smart-doc就能帮你生成一个简易明了的Markdown、HTML5、Postman Collection2.0+、OpenAPI 3.0+的文档。 无论你是很有经验的大佬、还是刚入行的萌新。遇到使用疑惑时，我们希望你能仔细阅读smart-doc官方文档。我们将smart-doc及其插件的每一个配置项和可能在日常中遇到的问题都整理到了文档中。仔细阅读文档就是对开源项目最大的支持。 特性 零注解、零学习成本、只需要写标准Java注释。 基于源代码接口定义自动推导，强大的返回结构推导。 支持Spring MVC、Spring Boot、Spring Boot Web Flux(Controller书写方式)、Feign。 支持Callable、Future、CompletableFuture等异步接口返回的推导。 支持JavaBean上的JSR303参数校验规范，包括分组验证。 对json请求参数的接口能够自动生成模拟json参数。 对一些常用字段定义能够生成有效的模拟值。 支持生成json返回值示例。 支持从项目外部加载源代码来生成字段注释(包括标准规范发布的jar包)。 支持生成多种格式文档：Markdown、HTML5、Asciidoctor、Postman Collection、OpenAPI 3.0。 开放文档数据，可自由实现接入文档管理系统。 支持导出错误码和定义在代码中的各种字典码到接口文档。 支持Maven、Gradle插件式轻松集成。 支持Apache Dubbo RPC接口文档生成。 debug接口调试html5页面完全支持文件上传，下载(@download tag标记下载方法)测试。 最佳实践png smart-doc + Torna 组成行业领先的文档生成和管理解决方案，使用smart-doc无侵入完成JAVA源代码分析和提取注释生成API文档，自动将文档推送到Torna企业级接口文档管理平台。 smart-doc+Torna文档自动化 Torna是由smart-doc官方独家推动联合研发的企业级文档管理系统，因此smart-doc官方不会对接其它任何的外部文档管理系统，例如像showdoc、yapi 之类的对接请自定内部处理，也不要再给我们提其他文档系统对接的PR。我们核心是把smart-doc+Torna的这套方案打造好 Contact 愿意参与构建smart-doc或者是需要交流问题可以扫描微信二维码发送smart-doc备注信息后管理园拉进群，常见问题答疑 1群已满，有问题请加2群。 谁在使用 排名不分先后，更多接入公司，欢迎在此处登记（仅供开源用户参考）                            获奖情况 2020 年度 OSC 中国开源项目评选”活动中获得「最积极运营项目」 致谢 感谢JetBrains SoftWare 为本开源项目提供的免费Open Source license。 License smart-doc is under the Apache 2.0 license. See the LICENSE file for details. 注意： smart-doc源代码文件全部带有版权注释，使用关键代码二次开源请保留原始版权，否则后果自负！ © All Rights Reserved            updated 2023-11-09 09:02:01 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"quickStart.html":{"url":"quickStart.html","title":"快速开始","keywords":"","body":"快速开始 smart-doc官方目前已经开发完成Maven插件和Gradle插件，本章以Maven插件举例. Gradle插件配置请跳转. 最小化配置 请保证你的代码格式符合最佳实践中的格式规范 在项目启动类所在模块的resources目录下创建smart-doc.json文件. { \"outPath\": \"/path/to/userdir\" } outPath也可以使用相对路径, 如: ./src/main/resources/static/doc 在项目启动类所在模块的pom.xml文件配置Maven插件, 注意: 需要includes依赖的源码包 com.github.shalousun smart-doc-maven-plugin [最新版本] ./src/main/resources/smart-doc.json ${project.description} com.baomidou:mybatis-plus-extension com.baomidou:mybatis-plus-core org.springframework.data:spring-data-commons compile html includes中需要调整为项目模块所依赖的包配置artifactId:groupId, 支持正则artifactId:* 如果项目依赖其他内部公共模块和二方包, 则依赖包需要配置源码打包. org.apache.maven.plugins maven-source-plugin 3.2.1 package jar-no-fork 如何使用 在IDEA中直接使用Maven插件目录下的smart-doc模块 在命令行中执行 mvn -Dfile.encoding=UTF-8 smart-doc:html mvn -Dfile.encoding=UTF-8 smart-doc:markdown mvn -Dfile.encoding=UTF-8 smart-doc:torna-rest ... © All Rights Reserved            updated 2023-11-05 16:37:29 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"guide.html":{"url":"guide.html","title":"使用指南","keywords":"","body":"使用指南 javadoc smart-doc的实现初衷是通过使用javadoc文档注释来去除注解式的侵入，因此smart-doc每增加一个功能首先都是去考虑javadoc原生的tag,下面对smart-doc使用的一些javadoc的注释tag做介绍。 tag 描述 since @param 对于在Spring Boot接口层，对于简单类型的参数必须在使用@param时写上注释描述，对于Entity类型smart-doc则不会检查 - @deprecated 可以在注释中用于标记接口已经废弃，作用同@Deprecated注解 - @apiNote smart-doc使用@apiNote的注释作为方法的详细描述，因此可以使用@apiNote来写一段长注释。如果一个方法不写 @apiNote注释说明，smart-doc直接使用方法默认注释填充 - @author smart-doc会提取代码中@author标注到文档中，@author可以写在方法上也可以写到类上。例如：@author sunyu on 2016/12/6. - @since smart-doc会提取代码中@since中的标注到文档中, 同时也对应了torna中的版本号 2.6.0 1. @param smart-doc针对JAVA原生的@param添加一些特殊的用法。 对基本类型请求参数设置mock值 /** * Test @RequestParam * @param author 作者|村上春树 * @param type type */ @GetMapping(\"testRequestParam\") public void testRequestParam(@RequestParam String author, @RequestParam String type) { } 参数对象替换 例如一些对象在框架底层做了特殊处理，smart-doc根据原始参数对象依赖过于强大的分析处理后的文档可能并不符合要求，这时你可以定义一个参数对象来替换，然后smart-doc按照你指定的对象来输出文档。 例如：使用JPA的Pageable作为接口参数接收对象时Spring框架做了处理，实际上真正的属性是PageRequest,不过smart-doc如果采用PageRequest会推导出一些不必要的属性， 该功能从smart-doc 1.8.5开始提供。 /** * 参数对象替换测试 * @param pageable com.power.doc.model.PageRequestDto * @return */ @PostMapping(value = \"/enum/resp\") public SimpleEnum resp(@RequestBody Pageable pageable){ return null; } 上面的写法中smart-doc就会使用com.power.doc.model.PageRequestDto代替JPA的Pageable做文档渲染，注意类名必须是全类名。 下面来看smart-doc支持的书写方式 @param pageable com.power.doc.model.PageRequestDto @param pageable 你的注释|com.power.doc.model.PageRequestDto # smart-doc本身基于泛型推导，如果需要泛型则需要写上具体的对象 @param pageable com.power.doc.model.PageRequestDto 尽量少采用这种参数替换的形式，代码书写很不方便，建议直接自己定义对象作为入参 2. @apiNote smart-doc使用@apiNote的注释作为方法的详细描述， 因此可以使用@apiNote来写一段长注释。如果一个方法不写@apiNote注释说明， smart-doc直接使用方法默认注释填充。@apiNote详细使用参考如下： /** * 查询用户信息 * @param name 用户名 * @apiNote 通过用户的名称去查询到用户的详细信息 * @return */ @PostMapping(value = \"/query\") public String resp(@RequestBody String name){ return null; } 3. @deprecated 可以在注释中用于标记接口已经废弃，作用同@Deprecated注解 /** * 查询用户信息 * @param name 用户名 * @apiNote 通过用户的名称去查询到用户的详细信息 * @deprecated * @return */ @PostMapping(value = \"/query\") public String resp(@RequestBody String name){ return null; } 4. @since /** * 查询用户信息 * @param name 用户名 * @apiNote 通过用户的名称去查询到用户的详细信息 * @since v2.1.0 * @return */ @PostMapping(value = \"/query\") public String resp(@RequestBody String name){ return null; } smart-doc tag 描述 since @ignore @ignore 如果@ignore加到方法上，则接口方法不会输出到文档。从1.8.4开始@ignore支持添加到Controller上进行忽略不想生成文档的接口类。@ignore也可以用于方法上忽略某个请求参数。 - @mock @mock tag用于在对象基本类型字段设置自定义文档展示值。设置值后smart-doc不再帮你生成随机值。方便可以通过smart-doc直接输出交付文档。 1.8.0 @dubbo @dubbo tag用于在Dubbo的API接口类上添加让smart-doc可以扫描到Dubbo RPC的接口生成文档。 1.8.7 @restApi @restApi tag用于支持smart-doc去扫描Spring Cloud Feign的定义接口生成文档。 1.8.8 @order @order tag用于设置Controller接口或者API入口的自定义排序序号，@order 1就表示设置序号为1。 1.9.4 @ignoreResponseBodyAdvice @ignoreResponseBodyAdvice tag用于忽略ResponseBodyAdvice设置的包装类。 1.9.8 @download @download tag用于标注在Controller的文件下载方法上，生成debug页面时可实现文件下载测试。并且支持下载文件带请求头参数测试。 2.0.1 @page @page tag用于标注在Controller的方法上表示该方法用来渲染返回一个静态页面，生成debug页面时如果发起测试，测试页面会自动在浏览器开启新标签显示页面。 2.0.2 @ignoreParams @ignoreParams tag用于标注在Controller方法上忽略掉不想显示在文档中的参数，例如：@ignoreParams id name，多个参数名用空格隔开 2.1.0 @response(不推荐) @response tag标注在Controller方法上可以允许用这自己定义返回的json example。建议只在返回基础类型时使用，如：Result类型这种泛型是简单原生类型的响应。 2.2.0 以上的一些自定义tag，我们建议国内的同学认真阅读这部分全部文档。包括后面对于一些tag的使用当中官方也给 了文字提示，不要去乱用。也不要觉得可以说服官方能够对当前的一些自定义tag做丰富。 首先我们是一个非常尊重编码规范的工具，我们不会去随便乱加一个东西来误导人，当前主流框架不提供的东西，我们不会在提供， 以后对tag的使用只会更加谨慎。 1. @ignore 2.6.9开始，@ignore不再支持在字段上标记。未来@ignore只能用于标注在方法和类的注释中。 对于实体字段，建议使用Json转换框架的注解去忽略，上面这种属于smart-doc早期的错误示范， 未来的版本中@ignore忽略字段的功能会被下线，Jackson和Fastjson的注解smart-doc都是支持的， 官方不建议采用这种无法做到表现和行为一致的方式。 /** * 发票管理 * @ignore */ @RestController @Slf4j @RequestMapping(\"invoice/invoice/v1\") @RequiredArgsConstructor public class InvoiceController { /** * 创建发票 * @ignore */ @PostMapping(\"/createInvoice\") public CommonResult createInvoice(@RequestBody InvoiceCreateRequest request) { return null; } } 2. @mock public class SimpleUser { /** * 用户名 * @mock 张三 * @since v1.0 */ @NotNull private String username; /** * 密码 * @mock 12356 * @since v1.0 */ private String password; } 在Controller层用SimpleUser作为参数接收，smart-doc不再使用随机值。 smart-doc输出的参数请求示例： { \"username\":\"张三\", \"password\":\"12356\" } 3. @download 用于告诉smart-doc。你的Controller中某一个方法是文件下载接口， smart-doc在生成debug调试页面时，可以生成一个文件下载的请求。后台参考代码如下： 接口无返回值, 需使用tag标记 /** * 下载普通文件文件 * @apiNote 方法没有返回对象可以识别，需要做download标记 * @param response * @return * @throws IOException * @download */ @PostMapping(\"text/\") public void download(HttpServletResponse response) throws IOException { String randomStr = RandomUtil.randomNumbers(50); String fileName = \"test.log\"; // urlDecode用于处理中文件名 // since 2.0.2后不需要在响应头设置filename response.setHeader(\"filename\", urlEncode(fileName)); ServletOutputStream outputStream = this.downloadText(fileName, response); outputStream.write(randomStr.getBytes()); } smart-doc 2.0.2版本将会自动从下载响应头Content-Disposition: attachment; filename=xx中读取文件名， 不再需要在响应头中设置response.setHeader(\"filename\", urlEncode(fileName)); 接口响应类型为以下时 org.springframework.core.io.Resource org.springframework.core.io.InputStreamSource org.springframework.core.io.ByteArrayResource org.noear.solon.core.handle.DownloadedFile国内solon框架 下面以返回org.springframework.core.io.Resource为例 /** * 下载文件 * @apiNote smart-doc自动识别文件流对象，不需要使用@download做文件下载标记 * @param filename 文件名|me * @return */ @PostMapping(\"download1/{filename}\") public ResponseEntity downloadFile(@PathVariable String filename) { String fileName = filename+\".log\"; String randomStr = RandomUtil.randomNumbers(50); Resource resource = new ByteArrayResource(randomStr.getBytes()); return ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment; filename=\\\"\" + fileName + \"\\\"\") .body(resource); } 4. @page 这个例子中用beetl来编写了一个html模板，正常情况下访问arthas-output.html。 会返回渲染后的界面，如果你想在debug页面中点击请求直接访问该页面， 那么你可以用@page来告诉smart-doc你的渲染页面名称。这样在debug页面上就可以直接帮你打开新的页签来访问页面。 /** * arthas火焰图列表 * * @return * @page /arthas-output.html * @apiNote 返回一个展示火焰图文件的arthas-output.html */ @GetMapping(\"arthas-output.html\") public String render() { Template template = BeetlTemplateUtil.getByName(\"arthas-output.tpl\"); List files = FileUtil.getFilesFromFolder(environment.getProperty(\"arthas.output.path\", OUTPUT_PATH)); template.binding(\"path\", \"arthas-output\"); template.binding(\"fileInfoList\", files); return template.render(); } 5. @ignoreParams 例如把id参数忽略掉，不要展示在文档中，这种主要是传统的有状态后台管理系统中的用户状态参数。 如果你要忽略的是一个Spring或者是JAX-RS这种顶级开源项目或者统一规范的参数时，请给官方提issue。例如你发现smart-doc不能忽略Spring 的@SessionAttribute注解的参数，那么你完全可以给官方提issue。 /** * 测试时间 * @ignoreParams id * @param id 编号 * @param dateEntity */ @PostMapping(\"data-date\") public CommonResult test(int id,@RequestBody DateEntity dateEntity){ return null; } 6. @response(不推荐) 对于使用@response的用户，我们只能认为你的代码是在太不清晰了，最好的就是代码写规范，让smart-doc能够自动生成返回样例。 /** * 测试response tag * * @return * @response { * \"success\": true, * \"message\": \"success\", * \"data\": \"hello\", * \"code\": \"68783\", * \"timestamp\": \"2021-06-15 23:05:16\" * } */ @GetMapping(\"/test\") public CommonResult create() { return null; } jsr 功能 注解 字段必填 @NotNull @NotEmpty @NotBlank 字段为空 @Null 长度限制 @Min @Max @Length @Size 分组校验 例如: 同一个实体类, 新增接口不需要传id, 而修改接口需要传id @Data @EqualsAndHashCode public class User { /** * id */ @Null(groups = Save.class) @NotNull(groups = Update.class) private Long id; /** * 名称 */ @Min(value = 4) @NotEmpty(message = \"名称不能为空\") private String name; /** * 邮件 */ @Length(max = 32) private String email; public interface Save extends Default { } public interface Update extends Default { } } @RestController @RequestMapping(\"validator\") public class ValidatorTestController { /** * 分组验证1 * @param collect * @return */ @PostMapping(\"/save\") public CommonResult save(@Validated({User.Save.class}) @RequestBody User user){ return CommonResult.ok(); } /** * 分组验证2 * @param collect * @return */ @PostMapping(\"/update\") public CommonResult update(@Validated({User.Update.class}) @RequestBody User user){ return CommonResult.ok(); } } © All Rights Reserved            updated 2023-11-19 10:51:17 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"bestPractice.html":{"url":"bestPractice.html","title":"最佳实践","keywords":"","body":"最佳实践 smart-doc是一款根据接口的泛型定义来在编译器期加载分析项源代码的返回类型和请求参数类型来实现的工具。 如果你在代码的接口定义中返回如下几种类型我们都将无法做处理。 响应类(使用泛型定义) 大多数成熟团队的统一返回类似如下(因文档篇幅，省略很多注释，使用smart-doc在真实代码中请规范些注释)，当然可以根据自己项目来定制。 public class CommonResult implements Serializable { /** * 是否成功 */ private boolean success = false; private String message; private T data; private String code; private String timestamp; } 接口请求 这种定义统一返回结构和明确的返回对象定义，smart-doc能够推导根据接口定义帮你推导出类的字段定义，包括嵌套的对象定义。 /** * 添加用户信息 * @param user * @return */ @PostMapping(\"/add\") public CommonResult addUser(@RequestBody User user){ return CommonResult.ok().setResult(user); } /** * 分页查询用户信息 * @param user * @return */ @PostMapping(\"/page\") public CommonResult> addUser(@RequestBody UserQuery query){ return CommonResult.ok().setResult(user); } 错误示例 1. 接口中使用Map 因为无法分析代码中Map的key值，所以smart-doc无法生成好的文档。 @GetMapping(value = \"/object\") public Map testMapUser() { return null; } 2. 返回JSONObject /** * 返回用户信息 * @return */ @GetMapping(value = \"/user\") public JSONObject object() { return null; } 团队中有这样定义返回数据一定要批评，鬼知道返回的是啥。程序员都看不懂，更别说smart-doc了。 3. 返回ModelMap /** * 返回用户信息 * @return */ @GetMapping(value = \"/user\") public ModelMap object() { return null; } 这个和Map是一个道理，并且smart-doc直接天生屏蔽ModelMap。 © All Rights Reserved            updated 2023-11-05 16:37:29 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"example.html":{"url":"example.html","title":"示例","keywords":"","body":"示例 单模块 项目目录结构 smart-doc-example-cn . ├── pom.xml ├── src │ ├── main │ │ ├── java │ │ │ └── com │ │ │ └── power │ │ │ └── doc │ │ │ └── controller │ │ │ └── entity │ │ │ └── service │ │ └── resources │ │ ├── application.yml │ │ └── smart-doc.json pom示例 4.0.0 com.power.doc smart-doc-example-cn 0.0.1-SNAPSHOT jar smart-doc-example-cn log4j2 org.springframework.boot spring-boot-starter-parent 3.1.1 org.springframework.boot spring-boot-maven-plugin com.github.shalousun smart-doc-maven-plugin ${smart-doc.version} com.power.doc:.* com.baomidou:mybatis-plus-extension--> com.github.shalousun:.* org.springframework:spring-web--> ./src/main/resources/smart-doc.json 测试 html 多模块 项目目录结构 其中dubbo-provider, spring-boot-web1, spring-boot-web2, spring-boot-web3, spring-boot-web4为各服务启动模块 spring-boot-maven-multiple-module-master ├── common │ ├── pom.xml ├── dubbo-api │ ├── pom.xml ├── dubbo-provider │ ├── pom.xml │ └── src │ ├── main │ │ ├── java │ │ │ └── com │ │ └── resources │ │ ├── application.yml │ │ ├── smart-doc.json ├── module2 │ └── pom.xml ├── pom.xml ├── spring-boot-web │ ├── pom.xml │ └── src │ └── main │ ├── java │ │ └── com │ └── resources │ ├── application.yml │ ├── smart-doc.json ├── spring-boot-web2 │ ├── pom.xml │ └── src │ └── main │ ├── java │ │ └── com │ └── resources │ ├── application.yml │ ├── smart-doc.json ├── spring-boot-web3 │ ├── pom.xml │ └── src │ └── main │ ├── java │ │ └── com │ └── resources │ ├── application.yml │ ├── smart-doc.json ├── spring-boot-web4 │ ├── pom.xml │ └── src │ └── main │ ├── java │ │ └── com │ └── resources │ ├── application.yml │ ├── smart-doc.json └── sub-module ├── pom.xml ├── simple-api │ ├── pom.xml └── web-test ├── pom.xml pom示例 最外层spring-boot-maven-multiple-module下的pom文件定义插件配置管理 4.0.0 com.power.test spring-boot-maven-multiple-module pom 0.1-SNAPSHOT common spring-boot-web spring-boot-web2 sub-module dubbo-api dubbo-provider spring-boot-web3 module2 spring-boot-web4 spring-boot-maven-multiple-module http://www.example.com org.springframework.boot spring-boot-starter-parent 3.1.0 UTF-8 17 17 com.github.shalousun smart-doc-maven-plugin 2.7.7 ${basedir}/src/main/resources/smart-doc.json 测试 html org.apache.maven.plugins maven-compiler-plugin 3.11.0 org.apache.maven.plugins maven-javadoc-plugin 3.5.0 dubbo-provider, spring-boot-web1, spring-boot-web2, spring-boot-web3, spring-boot-web4 spring-boot-maven-multiple-module com.power.test 0.1-SNAPSHOT 4.0.0 dubbo-provider dubbo-provider https://www.example.com org.springframework.boot spring-boot-maven-plugin com.github.shalousun smart-doc-maven-plugin org.apache.maven.plugins maven-compiler-plugin ${java.version} ${java.version} UTF-8 dubbo-provider © All Rights Reserved            updated 2023-11-05 16:37:29 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/config.html":{"url":"advanced/config.html","title":"配置项","keywords":"","body":"配置项 完整配置 配置 版本 必填 类型 默认值 描述 outPath ✔ String 指定文档的输出路径 serverUrl ❌ String http://127.0.0.1 服务器地址, 导出postman建议设置成http://{{server}}方便直接在postman直接设置环境变量。 2.4.8后导出postman建议使用serverEnv,避免多出导出时修改配置。 serverEnv 2.4.8 ❌ String 服务器地址, 导出postman建议设置成http://{{server}}方便直接在postman直接设置环境变量。改配置是为了支持postman导出时不用全局修改serverUrl pathPrefix 2.2.3 ❌ String 设置path前缀, 如配置Servlet ContextPath。 isStrict ❌ Boolean 是否开启严格模式,严格模式会强制检查代码注释，在2.6.3即以后的插件版本设置此项时检查到注释错误也会直接中断插件白嵌套的构建周期。 作为团队使用建议使用设置为true，提升对开发人员的注释要求，提升文档的完善度。 allInOne ❌ Boolean false 是否将文档合并到一个文件中，一般推荐为true。 coverOld ❌ Boolean false 是否覆盖旧的文件，主要用于Markdown文件覆盖。 createDebugPage 2.0.1 ❌ Boolean false smart-doc支持创一个类似Swagger那种可调试接口的HTML文档页面，仅在AllInOne模式中起作用。 从@2.0.1开始，对html文档，无论是allInOne还是非allInOne模式都能够生成debug页面。 packageFilters ❌ String Controller包过滤，多个包用英文逗号隔开。2.2.2开始需要采用正则：com.test.controller.* 2.7.1开始支持方法级别正则：com.test.controller.TestController.* packageExcludeFilters ❌ String 对packageFilters排除子包，多个包用英文逗号隔开2.2.2开始需要采用正则：com.test.controller.res.* md5EncryptedHtmlName ❌ Boolean false 只有每个Controller生成一个HTML文件是才使用。 style ❌ String 基于highlight.js的代码高亮设置。 projectName ❌ String 只有每个Controller生成一个HTML文件是才使用。 如果smart-doc.json中和插件中都未设置projectName，2.3.4开始，插件自动采用pom中的projectName作为默认填充， 因此使用插件时可以不配置。 sortByTitle 1.8.7 ❌ Boolean false 接口标题排序。 showAuthor ❌ Boolean true 是否显示接口作者名称。 requestFieldToUnderline 1.8.7 ❌ Boolean false 自动将驼峰入参字段在文档中转为下划线格式。 responseFieldToUnderline 1.8.7 ❌ Boolean false 自动将驼峰响应字段在文档中转为下划线格式。 inlineEnum 1.8.8 ❌ Boolean false 是否将枚举详情展示到参数表中。 recursionLimit 1.8.8 ❌ int 7 设置允许递归执行的次数用于避免一些对象解析卡主。 allInOneDocFileName 1.9.0 ❌ String index.html 只有配置项目所有Controller生成一个HTML文件时才生效。 requestExample 1.9.0 ❌ Boolean true 是否将请求示例展示在文档中。 responseExample 1.9.0 ❌ Boolean true 是否将响应示例展示在文档中。 urlSuffix 2.1.0 ❌ String 支持SpringMVC旧项目的url后缀。 language ❌ String CHINESE mock值的国际化支持。 displayActualType 1.9.6 ❌ Boolean false 是否在注释栏自动显示泛型的真实类型短类名。 appKey 2.0.9 ❌ String torna平台对接appKey。 appToken 2.0.9 ❌ String torna平台appToken。 secret 2.0.9 ❌ String torna平台secret。 openUrl 2.0.9 ❌ String torna平台地址，填写自己的私有化部署地址。 debugEnvName ❌ String torna环境名称。 replace 2.2.4 ❌ Boolean true 推送torna时替换旧的文档。改动还是会推送过去覆盖的，这个功能主要是保证代码删除了，torna上没有删除。 debugEnvUrl 2.0.9 ❌ String 推送torna配置接口服务地址。 tornaDebug 2.0.9 ❌ Boolean true 是否打印torna推送日志。 ignoreRequestParams 1.9.2 ❌ List 忽略请求参数对象，把不想生成文档的参数对象屏蔽掉。 dataDictionaries ❌ List 配置数据字典2.4.6开始可以配置枚举实现的接口， 当配置接口时title将使用实现枚举的类描述，如果有已经实现的枚举需要忽略的话，可以在实现枚举类上增加@ignore进行忽略。 errorCodeDictionaries ❌ List 错误码列表2.4.6开始可以配置枚举实现的接口， 当配置接口时title将使用实现枚举的类描述，如果有已经实现的枚举需要忽略的话，可以在实现枚举类上增加@ignore进行忽略。 revisionLogs ❌ List 文档变更记录。 customResponseFields ❌ List 自定义添加字段和注释，一般用户处理第三方jar包库。 customRequestFields ❌ List 自定义请求体的注释。 requestHeaders 2.1.3 ❌ List 设置公共请求头。 requestParams 2.2.3 ❌ List 公共请求参数(通过拦截器处理的场景)。 rpcApiDependencies ❌ List 项目开放的Dubbo API接口模块依赖，配置后输出到文档方便使用者集成。 rpcConsumerConfig ❌ String 文档中添加Dubbo Consumer集成配置，用于方便集成方可以快速集成。 apiObjectReplacements 1.8.5 ❌ List 使用自定义类覆盖其他类做文档渲染。 apiConstants 1.8.9 ❌ List 配置自己的常量类，smart-doc在解析到常量时自动替换为具体的值。 2.4.2版本开始使用到常量也无需配置，smart-doc已经能够自动解析。 responseBodyAdvice 1.8.9 ❌ List ResponseBodyAdvice是Spring框架中预留的钩子，它作用在Controller方法执行完成之后，http响应体写回客户端之前， 它能方便的织入一些自己的业务逻辑处理了，因此smart-doc也提供了对ResponseBodyAdvice统一返回设置(不要随便配置根据项目的技术来配置)支持， 可用ignoreResponseBodyAdvice tag来忽略。 requestBodyAdvice 2.1.4 ❌ List 设置RequestBodyAdvice统一请求包装类。 groups 2.2.5 ❌ List 对不同的Controller进行分组。 requestParamsTable 2.2.5 ❌ String 是否将请求参数表展示在文档中。 responseParamsTable 2.2.5 ❌ Boolean 是否将响应参数表展示在文档中。 framework 2.2.5 ❌ String spring or dubbo Spring和Apache Dubbo是smart-doc默认支持解析生成文档的框架，不配置framework时根据触发的文档构建场景自动选择Spring或者 Dubbo，smart-doc目前也支持JAX-RS的标准，因此使用支持JAX-RS标准的框架(如：Quarkus)可以作为体验使用，但是还不完善。可选值: spring,dubbo,JAX-RS,solon randomMock 2.6.9 ❌ Boolean false randomMock用于控制是否让smart-doc生成随机mock值，在2.6.9之前的版本中smart-doc会自动给参数和自动生成随机值， 每次生成的值都不一样，现在你可以设置为false来控制随机值的生成。 componentType 2.7.8 ❌ String RANDOM openapi component key generatorRANDOM : 支持 @Validated 分组校验 NORMAL: 不支持 @Validated, 用于 openapi 生成代码 { \"serverUrl\": \"http://127.0.0.1\", \"serverEnv\": \"http://{{server}}\", \"pathPrefix\": \"\", \"isStrict\": false, \"allInOne\": true, \"outPath\": \"D://md2\", \"randomMock\": false, \"coverOld\": true, \"createDebugPage\": true, \"packageFilters\": \"\", \"packageExcludeFilters\": \"\", \"md5EncryptedHtmlName\": false, \"style\": \"xt256\", \"projectName\": \"smart-doc\", \"framework\": \"spring\", \"skipTransientField\": true, \"sortByTitle\": false, \"showAuthor\": true, \"requestFieldToUnderline\": true, \"responseFieldToUnderline\": true, \"inlineEnum\": true, \"recursionLimit\": 7, \"allInOneDocFileName\": \"index.html\", \"requestExample\": \"true\", \"responseExample\": \"true\", \"requestParamsTable\": true, \"responseParamsTable\": true, \"urlSuffix\": \".do\", \"displayActualType\": false, \"appToken\": \"c16931fa6590483fb7a4e85340fcbfef\", \"isReplace\": true, \"openUrl\": \"http://localhost:7700/api\", \"debugEnvName\": \"测试环境\", \"debugEnvUrl\": \"http://127.0.0.1\", \"tornaDebug\": false, \"ignoreRequestParams\": [ \"org.springframework.ui.ModelMap\" ], \"dataDictionaries\": [ { \"title\": \"http状态码字典\", \"enumClassName\": \"com.power.common.enums.HttpCodeEnum\", \"codeField\": \"code\", \"descField\": \"message\" }, { \"enumClassName\": \"com.xx.IEnum\", \"codeField\": \"code\", \"descField\": \"message\" } ], \"errorCodeDictionaries\": [ { \"title\": \"title\", \"enumClassName\": \"com.power.common.enums.HttpCodeEnum\", \"codeField\": \"code\", \"descField\": \"message\", \"valuesResolverClass\": \"\" }, { \"enumClassName\": \"com.xx.IEnum\", \"codeField\": \"code\", \"descField\": \"message\" } ], \"revisionLogs\": [ { \"version\": \"1.0\", \"revisionTime\": \"2020-12-31 10:30\", \"status\": \"update\", \"author\": \"author\", \"remarks\": \"desc\" } ], \"customResponseFields\": [ { \"name\": \"code\", \"desc\": \"响应代码\", \"ownerClassName\": \"org.springframework.data.domain.Pageable\", \"ignore\": true, \"value\": \"00000\" } ], \"customRequestFields\": [ { \"name\": \"code\", \"desc\": \"状态码\", \"ownerClassName\": \"com.xxx.constant.entity.Result\", \"value\": \"200\", \"required\": true, \"ignore\": false } ], \"requestHeaders\": [ { \"name\": \"token\", \"type\": \"string\", \"desc\": \"desc\", \"value\": \"token请求头的值\", \"required\": false, \"since\": \"-\", \"pathPatterns\": \"/app/test/**\", \"excludePathPatterns\": \"/app/page/**\" }, { \"name\": \"appkey\", \"type\": \"string\", \"desc\": \"desc\", \"value\": \"appkey请求头的值\", \"required\": false, \"pathPatterns\": \"/test/add,/testConstants/1.0\", \"since\": \"-\" } ], \"requestParams\": [ { \"name\": \"configPathParam\", \"type\": \"string\", \"desc\": \"desc\", \"paramIn\": \"path\", \"value\": \"testPath\", \"required\": false, \"since\": \"-\", \"pathPatterns\": \"**\", \"excludePathPatterns\": \"/app/page/**\" }, { \"name\": \"configQueryParam\", \"type\": \"string\", \"desc\": \"desc\", \"paramIn\": \"query\", \"value\": \"testQuery\", \"required\": false, \"since\": \"-\", \"pathPatterns\": \"**\", \"excludePathPatterns\": \"/app/page/**\" } ], \"rpcApiDependencies\": [ { \"artifactId\": \"SpringBoot2-Dubbo-Api\", \"groupId\": \"com.demo\", \"version\": \"1.0.0\" } ], \"rpcConsumerConfig\": \"src/main/resources/consumer-example.conf\", \"apiObjectReplacements\": [ { \"className\": \"org.springframework.data.domain.Pageable\", \"replacementClassName\": \"com.power.doc.model.PageRequestDto\" } ], \"apiConstants\": [ { \"constantsClassName\": \"com.power.doc.constants.RequestParamConstant\" } ], \"responseBodyAdvice\": { \"className\": \"com.power.common.model.CommonResult\" }, \"requestBodyAdvice\": { \"className\": \"com.power.common.model.CommonResult\" }, \"groups\": [ { \"name\": \"测试分组\", \"apis\": \"com.power.doc.controller.app.*\" } ], \"requestParamsTable\": true, \"responseParamsTable\": true, \"componentType\": 1 } packageFilters Controller包过滤，多个包用英文逗号隔开。 PS: 2.2.2开始需要采用正则：com.test.controller. ，2.7.1开始支持方法级别正则：com.test.controller.TestController. { \"packageFilters\": \"com.test.controller.*\", // 输出 controller 包下所有的接口 \"packageFilters\": \"com.example.controller.PetController\", // 只输出 PetController 的接口 \"packageFilters\": \"com.example.controller.*Controller\", // 输出 controller 包下以 Controller 后缀为类名的所有接口 \"packageFilters\": \"com.example.controller.Pet.*\", // 输出 controller 包下以 Pet 开头为类名的所有接口 \"packageFilters\": \"com.example.controller.Pet.*Controller\", // 输出 controller 包下符合 Pet*Controller 类名的所有接口 \"packageFilters\": \"com.example.controller.PetController.getPetInfo\", // 输出 PetController 中 getPetInfo 方法接口 \"packageFilters\": \"com.example.controller.PetController.*\", // 输出 PetController 中所有的接口 \"packageFilters\": \"com.example.controller.PetController.get.*\", // 只输出 PetController 类中以 get 为方法名开头的所有接口 \"packageFilters\": \"com.example.controller.PetController.*Info\", // 只输出 PetController 类中以 Info 为方法名结尾的所有接口 \"packageFilters\": \"com.example.controller.PetController.get.*Info\", // 只输出 PetController 类中符合 get.*Info 为方法名的所有接口 } dataDictionaries 配置数据字典，2.4.6开始可以配置枚举实现的接口， 当配置接口时title将使用实现枚举的类描述，如果有已经实现的枚举需要忽略的话，可以在实现枚举类上增加@ignore进行忽略。 配置 类型 描述 title String enumClassName String 错误码枚举类 codeField String 错误码的code码字段名称，smart-doc默认以getCode方法名去反射获取。如果没有get方法可以配置字段对应方法名，例如：code()。 descField String 错误码的描述信息对应的字段名，和codeField一样可以配置为方法名,例如：message() { \"dataDictionaries\": [ { \"title\": \"title\", \"enumClassName\": \"com.power.common.enums.HttpCodeEnum\", \"codeField\": \"code\", \"descField\": \"message\" } ] } errorCodeDictionaries 错误码列表，2.4.6开始可以配置枚举实现的接口， 当配置接口时title将使用实现枚举的类描述，如果有已经实现的枚举需要忽略的话，可以在实现枚举类上增加@ignore进行忽略。 配置 类型 描述 title String enumClassName String 错误码枚举类 codeField String 错误码的code码字段名称，smart-doc默认以getCode方法名去反射获取。如果没有get方法可以配置字段对应方法名，例如：code()。 descField String 错误码的描述信息对应的字段名，和codeField一样可以配置为方法名,例如：message() { \"errorCodeDictionaries\": [ { \"title\": \"title\", \"enumClassName\": \"com.power.common.enums.HttpCodeEnum\", \"codeField\": \"code\", \"descField\": \"message\" } ] } revisionLogs 文档变更记录。 配置 类型 描述 version String 文档版本号 revisionTime String 文档修订时间 status String 变更操作状态，一般为：创建、更新等 author String 文档变更作者 remarks String 变更描述 { \"revisionLogs\": [ { \"version\": \"1.0\", \"revisionTime\": \"2020-12-31 10:30\", \"status\": \"update\", \"author\": \"author\", \"remarks\": \"desc\" } ] } customResponseFields 自定义添加字段和注释，一般用户处理第三方jar包库。 配置 类型 描述 name String 覆盖响应码字段 desc String 覆盖响应码的字段注释 ownerClassName String 指定你要添加注释的类名 ignore Boolean 设置true会被自动忽略掉不会出现在文档中 value String 设置响应码的值 { \"customResponseFields\": [ { \"name\": \"code\", \"desc\": \"响应代码\", \"ownerClassName\": \"org.springframework.data.domain.Pageable\", \"ignore\": true, \"value\": \"00000\" } ] } customRequestFields 自定义添加字段和注释，一般用户处理第三方jar包库。 配置 类型 描述 name String 属性名 desc String 描述 ownerClassName String 属性对应的类全路径 ignore Boolean 是否忽略 required Boolean 是否必填 value String 默认值或者mock值 { \"customRequestFields\": [ { \"name\": \"code\", \"desc\": \"状态码\", \"ownerClassName\": \"com.xxx.constant.entity.Result\", \"value\": \"200\", \"required\": true, \"ignore\": false } ] } rpcApiDependencies 项目开放的Dubbo API接口模块依赖，配置后输出到文档方便使用者集成。 配置 类型 描述 artifactId String artifactId groupId String groupId version String 版本号 { \"rpcApiDependencies\": [ { \"artifactId\": \"SpringBoot2-Dubbo-Api\", \"groupId\": \"com.demo\", \"version\": \"1.0.0\" } ] } apiObjectReplacements 使用自定义类覆盖其他类做文档渲染。 配置 类型 描述 className String 需要被替换的全类名 replacementClassName String 用于被替换的全类名 { \"apiObjectReplacements\": [ { \"className\": \"org.springframework.data.domain.Pageable\", \"replacementClassName\": \"com.power.doc.model.PageRequestDto\" //自定义的PageRequestDto替换Pageable做文档渲染 } ] } responseBodyAdvice ResponseBodyAdvice是Spring框架中预留的钩子，它作用在Controller方法执行完成之后，http响应体写回客户端之前， 它能方便的织入一些自己的业务逻辑处理了，因此smart-doc也提供了对ResponseBodyAdvice统一返回设置(不要随便配置根据项目的技术来配置)支持， 可用ignoreResponseBodyAdvice tag来忽略。 配置 类型 描述 className String 通用响应体 { \"responseBodyAdvice\": { \"className\": \"com.power.common.model.CommonResult\" } } requestBodyAdvice 设置RequestBodyAdvice统一请求包装类。 配置 类型 描述 className String 通用请求体 { \"requestBodyAdvice\": { \"className\": \"com.power.common.model.CommonResult\" } } groups 对不同的Controller进行分组。 PS: 分组不对postman.json和openApi.json生效 配置 类型 描述 name String 分组名称 apis String 分组url, 支持正则 { \"groups\": [ { \"name\": \"测试分组\", \"apis\": \"com.power.doc.controller.app.*\" } ] } © All Rights Reserved            updated 2023-11-10 08:29:28 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/advanced.html":{"url":"advanced/advanced.html","title":"高级特性","keywords":"","body":"高级特性 公共请求头 requestHeaders 在smart-doc 2.2.2以前的版本中，在smart-doc.json中设置请求头是这样的 { \"requestHeaders\": [ //设置请求头，没有需求可以不设置 { \"name\": \"token\", //请求头名称 \"type\": \"string\", //请求头类型 \"desc\": \"desc\", //请求头描述信息 \"value\": \"kk\", //不设置默认null \"required\": false, //是否必须 \"since\": \"-\", //什么版本添加的改请求头 // since 2.2.2 \"pathPatterns\": \"/app/test/**\", //只有以/app/test/开头的url才会有此请求头 \"excludePathPatterns\": \"/app/login\" // 登录url=/app/page/将不会有该请求头 } ] } 很多用户在issue中说他们的token是通过拦截器拦截的，并没有显示的在接口层面去申明请求头。在2.2.2版本开始，我们增加了两个配置属性： pathPatterns 配置请求头的作用路径，和拦截器配置pathPatterns一致的，多个正则式之间用逗号隔开。 excludePathPatterns 配置在那些path上忽略该请求头。和拦截器的excludePathPatterns一致的，多个正则式之间用逗号隔开。 smart-doc完全借鉴了Spring的PathMatcher的匹配，因此相关的路径正则规则也是和PathMatcher一致的， 使用时请自行研究下PathMatcher并书写正确正则表达式，否则可能配置了后效果和你想的不一样。 公共请求参数 @since 2.2.3 requestParams { \"requestParams\": [ { \"name\": \"configPathParam\", //请求参数名称 \"type\": \"string\", //请求参数类型 \"desc\": \"desc\", //请求参数描述信息 \"paramIn\": \"path\", // path 或者query \"value\": \"testPath\", //不设置默认null \"required\": false, //是否必须 \"since\": \"-\", //什么版本添加的改请求参数 \"pathPatterns\": \"**\", //正则表达式过滤请求, 所有参数都会有此参数 \"excludePathPatterns\": \"/app/page/**\" //参考请求头中的用法 } ] } paramIn path: path参数, id为公共请求参数 /** * 接收数组类型pathVariable * @return */ @GetMapping(\"/test/{id}\") public CommonResult testPathVariable(@PathVariable(\"id\") String[] id ) { return CommonResult.ok().setResult(id); } query: query参数, configQueryParam为公共请求参数 /** * post请求测试query参数 * * @tag 顶顶顶到达 * @author cqmike * @return */ @PostMapping(\"configQueryParamPost\") public CommonResult configQueryParamPost(String configQueryParam) { return CommonResult.ok(); } 静态常量替换 2.4.2版本开始，这个配置无需在手动添加，smart-doc可以自动识别静态常量的使用。 在Java Web接口开发的过程中，有用户会在Controller的path中使用静态场景。因此也是希望smart-doc能够解析静态常量获取到真实的值。 下面来看下例子： /** * Test Constants * * @param page 页码 */ @GetMapping(value = \"testConstants/\" + ApiVersion.VERSION) public void testConstantsRequestParams(@RequestParam(required = false, defaultValue = RequestValueConstant.PAGE_DEFAULT_NONE, value = RequestParamConstant.PAGE) int page) { } 针对这种常量的使用，smart-doc要求用户配置产量类，smart-doc根据设置的常量类分析形成常量容器，在做接口分析是从常量容器中查找做替换。 配置参考输入： { \"allInOne\":true, \"apiConstants\":[{ \"constantsClassName\":\"com.power.doc.constants.RequestParamConstant\" },{ \"constantsClassName\":\"com.power.doc.constants.RequestValueConstant\" },{ \"constantsClassName\":\"com.power.doc.constants.ApiVersion\" }] } 注意： 如果配置类名时使用到内部类不要写错了，子类是使用$符号相连， 例如：com.power.doc.controller.UserController$ErrorCodeEnum 如果是单元测试，配置参考如下 ApiConfig config = new ApiConfig();// @Deprecated ApiConfig config = ApiConfig.getInstance(); config.setApiConstants( ApiConstant.builder().setConstantsClass(RequestParamConstant.class), ApiConstant.builder().setConstantsClass(RequestValueConstant.class), ApiConstant.builder().setConstantsClass(ApiVersion.class) ); 由于存在不同常量类中常量同名的情况，因此smart-doc在加载配置的常量类创建常量池的时候，每个常量是带上类名前缀的。 例如ApiVersion类中的VERSION常量。最后的名字是ApiVersion.VERSION。这就要求在使用常量的时候使用类名.常量名的方式。 当然常量是是写在接口中还是普通的常量类中都是支持加载解析的。 响应字段忽略 有同学在使用smart-doc时提问：“如何忽略响应实体中的某个字段？”，例如像密码password这种字段敏感字段，smart-doc在一开始开发的时候就考虑到了这种情况， 因此我们对Java的一些json序列化库做了支持，像Spring框架默认使用的Jackson和国内用户使用较多的Fastjson都是支持的。 为什么不用@ignore来标注返回字段忽略？这是一种掩耳盗铃的做法，仅仅是表面文档不展示，数据依旧返回了，因此这是smart-doc不支持的原因。还是使用框架的注解来控制吧。 使用jackson注解忽略 一般spring框架默认使用的是jackson作为json序列化和反序列化库。 public class JacksonAnnotation { /** * 用户名 */ @JsonProperty(\"name\") private String username; /** * 身份证号 */ @JsonIgnore private String idCard; } 像这个idCard使用@JsonIgnore注解后，接口不会看到该字段，smart-doc发现该注解也不会把该字段显示在接口文档中。 Fastjson忽略响应字段 Fastjson也自己用于忽略字段的注解，Fastjson使用 @JSONField(serialize = false),起关键作用的是serialize = false public class FastJson { /** * 用户名 */ @JSONField(name = \"name\") private String username; /** * 身份证号 */ @JSONField(serialize = false) private String idCard; } 如果你在项目中使用了Fastjson替代默认的Jackson，按照上面的idCard字段这样写上注解后，无论是真实的数据响应还是smart-doc的文档都能帮你 忽略掉相关字段。 忽略高级设置 smart-doc官方还支持Fastjson和Jackson的高级忽略配置，例子如下： /** * 测试mybatis-plugs page字段忽略 * @author yu 2021/7/11. */ @JSONType(ignores ={\"current\", \"size\", \"orders\", \"hitCount\", \"searchCount\", \"pages\",\"optimizeCountSql\"}) @JsonIgnoreProperties({\"current\", \"size\", \"orders\", \"hitCount\", \"searchCount\", \"pages\",\"optimizeCountSql\"}) public class MybatisPlusPage extends Page { } 导出数据字典 在Swagger中针对国内的场景，是很难做到字典导出的。但是smart-doc中可以很容易的把枚举字典导出到文档中。 例如代码中有一个订单状态枚举字典。 public enum OrderEnum { WAIT_PAY(\"0\", \"已支付\"), PAID(\"1\", \"已支付\"), EXPIRED(\"2\",\"已经失效\"); private String code; private String desc; OrderEnum(String code, String desc) { this.code = code; this.desc = desc; } public String getCode() { return this.code; } public String getDesc() { return this.desc; } } 配置一下就可以导出， @since 2.4.6版本开始，此配置支持配置枚举所实现的接口来获取子类实现类， 如果有已经实现的枚举需要忽略的话，可以在实现枚举类上增加@ignore进行忽略。 { \"dataDictionaries\": [ { \"title\": \"订单状态码字典\", //数据字典的名称 \"enumClassName\": \"com.xx.OrderEnum\", //数据字典枚举类名称 \"codeField\": \"code\", //数据字典字典码对应的字段名称,smart-doc默认以getCode方法名去反射获取。如果没有get方法可以配置字段对应方法名，例如：code()。 \"descField\": \"message\" //数据字典对象的描述信息字典，和codeField一样可以配置为方法名,例如：message() }, { \"enumClassName\": \"com.xx.IEnum\", //数据字典接口 \"codeField\": \"code\", //数据字典字典码对应的字段名称 \"descField\": \"message\" //数据字典对象的描述信息字典 } ] } 注意： 如果配置类名时使用到内部类不要写错了，子类是使用$符号相连， 例如：com.power.doc.controller.UserController$ErrorCodeEnum 由于smart-doc为了减少用户去配置字典项，因此使用的反射原理去遍历的枚举项，反射是不能获取到注释的， 这里就要求字典的描述直接定义在编码中。当然错误字典也是同理来处理。 外部源码加载 为什么外部jar没有注释 在编译Java代码打包成jar包后，编译器会将代码中的注释去除，并且泛型也被擦除(例如定义泛型T,编译后T将变成Object), smart-doc是依赖泛型和源码推荐出文档的，因此如果接口使用的类来自外部jar包或者是其他模块， 那么需要做一些处理才能让smart-doc能够正确分析出文档。 如何让smart-doc加载源码 smart-doc作为一款完全依赖源码注释来分析生成文档的工具。如果没有源代码，那么在生成文档时将只能看到字段名和字段类型等信息， 注释相关的信息都将无法生成，对于一个所有代码都在一个单独项目中的情况，你不需要考虑任何东西，smart-doc能完美的完成你想要的文档， 但是对一个多模块项目，或者项目依赖了一个独立的jar包的情况，smart-doc将无法加载到它所运行模块之外的代码。 下面将会介绍如何来让smart-doc加载到运行模块外的项目代码。 注意：自smart-doc-maven-plugin 1.0.2版本开始，使用maven的插件能够实现自动源码加载。 通过ApiConfig类设置(不推荐) 代码示例如下： ApiConfig config = new ApiConfig();// @Deprecated ApiConfig config = ApiConfig.getInstance(); //以前的版本为setSourcePaths，SourceCodePath为SourcePath config.setSourceCodePaths( SourceCodePath.path().setDesc(\"本项目代码\").setPath(\"src/main/java\"), //smart-doc对路径自动会做处理，无论是window合适linux系统路径，直接拷贝贴入即可 SourceCodePath.path().setDesc(\"加载外部项目源码\").setPath(\"E:\\\\Test\\\\Mybatis-PageHelper-master\\\\src\\\\main\\\\java\") ); 这样smart-doc就能将外部的源码载入。 通过maven的classifier来指定源码包(不推荐) 官方不推荐这样使用，如果你们团队比较规范，领导要求严格，下面的配置纯属找骂， 请使用smart-doc提供的官方插件来集成，最好保持项目pom配置的清爽整洁。 这里先看如何使用classifier来加载源码包。 com.github.shalousun common-util 1.8.6 com.github.shalousun common-util 1.8.6 sources test 这样不需要像上面一样设置源码加载路径了。但是并不是所有的打包都能有源码包。需要在打包是做规范化处理。 注意： 在加载jar包和source源码jar包时，如出现代码导入错误可尝试变更二者依赖顺序， 推荐使用smart-doc最新的Maven插件或者Gradle插件。 公有jar打包规范(推荐) 当你发布公共jar包或者Dubbo应用API接口共有jar包时，在maven的plugins中加入maven-source-plugin,示例如下： org.apache.maven.plugins maven-source-plugin 3.2.1 package jar-no-fork 这样发布的时候就会生成一个[your jar name]-sources.jar的源码包，这个包也会一起发布到私有仓库。这样就可以通过classifier来指定sources了。如果还是不清楚可以直接参考smart-doc源码的pom.xml配置。 注意： 经测试验证，如果只是通过install到本地，即便是指定了sources也无法读取到源码，只有将公用的模块deploy到nexus这样的私服上才能正常使用。 对于什么时候需要自己发布jar包，很多新手是不知道的，这里介绍主要的场景： A工程里写了一个通用的模块，例如通用工具类模块，想在B工程里直接依赖使用。 Dubbo的RPC API模块这种场景，其项目业务要调用你的Dubbo，如果都使用JAVA开发直接依赖Dubbo API模块就可以。 第三方源码示例 当前在做项目开发时难免会使用到一些第三方的开源工具或者是框架，例如：mybatis-plus，smart-doc本身是基于源代码来分析的， 如果没有源代码smart-doc将不能正确的生成完整的接口文档。 当然如果使用smart-doc-maven-plugin 1.0.2版本开始的插件， 插件可以自动加载到相关使用依赖的源码，使用插件后就不需要自行去配置source的依赖了，推荐使用插件 mybatis-plus分页处理 在使用mybatis-plus的分页时，如果使用IPage作为Controller层的返回，smart-doc无论如何也不能扫描出正确的文档， 因为IPage是一个纯接口，所以可以在service层正常使用IPage作为分页返回，然后在Controller层做下转换。 /** * 分页查询订单信息 * @param pageIndex 当前页码 * @param pageSize 页面大小 * @return */ @GetMapping(value = \"page/{pageIndex}/{pageSize}\") public Page queryPage(@PathVariable int pageIndex , @PathVariable int pageSize) { Page page = new Page<>(pageIndex,pageSize); page.setRecords(orderService.selectPage(pageIndex,pageSize).getRecords()); return page; } 当然也要在项目中引入mybatis-plus的源码 com.baomidou mybatis-plus-extension 3.2.0 sources test classifier这种方式都不推荐使用，请使用maven插件或者gradle插件，插件可以实现自动加载。 自定义错误码解析器 现在很多人使用枚举作为字典码，对于枚举类smart-doc可以根据配置很容易就完成扫描到文档中。 但是对于采用非枚举的情况就需要自己去编写对应的自定解析类了。自定义的解析类必须实现smart-doc 的com.power.doc.extension.dict.DictionaryValuesResolver。接口代码如下： public interface DictionaryValuesResolver { Collection resolve(); } 实现例子： public class EExceptionValuesResolver implements DictionaryValuesResolver { @Override public Collection resolve() { List list = new ArrayList<>(); //反射处理你自己的错误码代码，填充返回 return list; } } 然后在smart-doc配置中执行自己的错误码解析器 \"errorCodeDictionaries\": [ { //错误码列表，没有需求可以不设置 \"title\": \"title\", \"valuesResolverClass\": \"xx.EExceptionValuesResolver\" //自定义错误码解析器，使用枚举定义错误码的忽略此项。 } } © All Rights Reserved            updated 2023-11-05 16:34:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"advanced/debug.html":{"url":"advanced/debug.html","title":"接口调试","keywords":"","body":"接口UI集成 smart-doc调试页面 从smart-doc 2.0.0版本开始，在html的allInOne的模式下。可以添加\"createDebugPage\": true的配置。smart-doc会 创建一个debug.html的页面。 在让生成smart-doc生成文档时直接放入到static/doc/下， 这样可以直接启动程序访问页面localhost:8080/doc/debug.html进行开发调试。 从smart-doc 2.0.1开始，对html文档，无论是allInOne还是非allInOne模式都能够生成debug页面。smart-doc目前的debug页面支持文件上传和文件下载测试。 配置 { \"serverUrl\": \"http://localhost:8080\", \"isStrict\": false, \"allInOne\": true, \"outPath\": \"src/main/resources/static/doc\", \"coverOld\": true, \"style\":\"xt256\",//喜欢json高亮的可以设置 \"createDebugPage\": true, //启用生成debug \"md5EncryptedHtmlName\": false, \"projectName\": \"SpringBoot2-Open-Api\" } 跨域配置 有的开发人员直接在idea中使用【Open In Browser】打开smart-doc生成的debug页面， 如果非要这做，前端js请求后台接口时就出现了跨域。因此你需要在后端配置跨域。 这里以SpringBoot为例： @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { /** * 跨域配置会覆盖默认的配置， * 因此需要实现addResourceHandlers方法，增加默认配置静态路径 * @param registry */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\") .addResourceLocations(\"classpath:/resources/\") .addResourceLocations(\"classpath:/static/\"); } @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowedMethods(\"*\") .allowCredentials(true); } } 如果采用服务器方式来访问页面，则无需配置。 界面效果 debug页面调试 在使用smart-doc生成的html调试页面做接口调试时，你可能会碰到一下问题， 通常当点击Send Request按钮后，按钮变成了红色就说明接口出错或者是debug页面出现错误。 这时请打开浏览器的调试控制台查看问题或者是调试。smart-doc创建的页面中只是用了jquery和原生js来开发的， debug.js是用于处理接口测试请求的，search.js是用于处理文档目录标题搜索的。源码都未做压缩，可以直接调试页面的js源码。 调试操作参考如下图： Swagger是通过侵入一个web接口模块到项目中实现了调试接口调试功能，由于smart-doc不侵入代码中，打包的代码中看不到任何smart-doc的 依赖，因此如果你想调试接口只能生成html文档到src/resources/static目录中，这样SpringBoot就能自动渲染范围这个html文档页面。 当然smart-doc的调试页面对于文件上传你只能传一个文件，这点相比Swagger UI要弱。但是smart-doc也有比Swagger UI强的地方， 例如：文档展示更清晰明了；支持测试文件下载 Postman导入调试 从smart-doc 1.7.8版本开始，smart-doc支持生成Postman的json文件， 你可以使用smart-doc生成整个项目的或者某个微服务所有接口的Postman的json文件， 然后通过将这个json文件导入Postman的Collections做测试。导出json. 导入json到Postman效果如下图： postman中设置环境变量 注意： 在Add Environment中不要忘记给环境设置名称(例如：本地开发测试)，否则按上图不能保存成功。 smart-doc自动生成的Json文件会贴心的给在Postman中给填充上注释，如果你自己写了mock值也会携带进入， 远比自己手动填省心多了 swagger UI集成 smart-doc支持生成openapi 3.0+规范的接口文档，因此你可以使用支持openapi 3.0+规范的文档管理系统或者ui界面来 展示smart-doc生成的文档。 本文来说下如何快速集成swagger ui来在开发中测试你的接口。 添加依赖 org.springdoc springdoc-openapi-ui 1.5.0 smart-doc支持的openapi规范版本比较高，因此需要集成1.5.0或者是更高的版本。 配置swagger ui 在application配置文件中添加如下配置 # custom path for swagger-ui springdoc: swagger-ui: path: /swagger-ui-custom.html operations-sorter: method #custom path for api docs url: /doc/openapi.json url是配置的关键，代表指向smart-doc生成的openapi.json文件。并且你需要将openapi生成到src/main/resources/static/doc下。 生成好api文件后启动你的应用访问localhost:8080/swagger-ui-custom.html即可看到文档。 接下来你就可以在开发的时候使用这个ui界面来自测了。 提醒： 关于swagger ui的其他配置就自行研究吧，我们也不会。 © All Rights Reserved            updated 2023-11-05 16:34:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"integrated/torna.html":{"url":"integrated/torna.html","title":"torna","keywords":"","body":"torna集成 简介 smart-doc从2018年的开源后的持续发展中，我们收到了很多的用户的需求， 很多企业用户非常需要一个好用的集中化API管理平台。在过去Yapi可以说是国内开源市场长用户量比较多的开源产品。但是在smart-doc作者长期的观察中，Yapi有诸多的问题。因此2020年，我们一直在社区寻找合适的开源合作者来重心打造一款企业级的API文档管理平台。很幸运的在开源社区找到了@tanghc。 @tanghc是一个有多个开源项目的作者，而且非常热衷于开源。我们向 @tanghc 描述了做API管理平台的项目和理念。最终我们达成了做torna的共识。为开源社区提供一个好的文档生成和管理的解决方案。当然未来我们会探索出商业化的产品。 但是smart-doc和smart-doc的maven、gradle插件是免费。当前提供的torna基础功能也是免费开源给社区使用。torna商业版本主要面向企业的高级功能版本。 文档全流程自动化 smart-doc + Torna 组成行业领先的文档生成和管理解决方案，使用smart-doc无侵入完成Java源代码分析和提取注释生成API文档，自动将文档推送到Torna企业级接口文档管理平台。 需要从smart-doc 2.0.9才支持推送文档到torna，当然推荐使用smart-doc同学关注新版本的发布。推荐smart-doc和torna都使用最新的版本。 如何把文档自动推送到torna 首先是在java的spring项目中集成smart-doc。smart-doc的集成看smart-doc官方的其他文档。其实smart-doc一直的理念都是让使用变的简单。因此要把文档推送到smart-doc也很简单，只需要在smart-doc.json文件中添加几行推送到torna的配置 { \"serverUrl\": \"http://127.0.0.1\", //服务器地址,非必须。导出postman建议设置成http://方便直接在postman直接设置环境变量 \"isStrict\": false, //是否开启严格模式 \"outPath\": \"\", //指定文档的输出路径,maven插件不需要，gradle插件必须 \"packageFilters\": \"\",//controller包过滤，多个包用英文逗号隔开 \"projectName\": \"smart-doc\",//配置自己的项目名称 \"appToken\": \"c16931fa6590483fb7a4e85340fcbfef\", //torna平台appToken,@since 2.0.9 \"appKey\": \"20201216788835306945118208\",//torna平台对接appKey，torna 1.11.0版本后不再需要, @since 2.0.9, \"secret\": \"W.ZyGMOB9Q0UqujVxnfi@.I#V&tUUYZR\",//torna平台secret，torna 1.11.0版本后不再需要，@since 2.0.9 \"openUrl\": \"http://localhost:7700/api\",//torna平台地址，填写自己的私有化部署地址@since 2.0.9 \"debugEnvName\":\"测试环境\", //torna测试环境 \"replace\": true,//推送torna时替换旧的文档 \"debugEnvUrl\":\"http://127.0.0.1\",//torna } 注意： appKey,appToken,secret如果你不是管理员需要去问管理员了解你推送的项目具体的相关信息。 Torna从1.11.0版本开始，使用smart-doc推送文档数据已经不再需要配置appKey和secret， 仅需要配置appToken即可，因此建议升级Torna版本。 如果你是管理员可以在torna的空间管理中查看。 查看空间里相关项目的token 推送操作 集成smart-doc并完成推送配置后，就可以使用利用smart-doc的maven或者是gradle插件来直接把文档推送到torna中了。 如果你想使用命令行或者是gradle，请查看smart-doc官方maven和gradle插件使用的文档，此处不再赘述。 © All Rights Reserved            updated 2023-11-05 16:34:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"integrated/dubbo.html":{"url":"integrated/dubbo.html","title":"dubbo","keywords":"","body":"简介 smart-doc从1.8.7版本开始支持Dubbo API文档的生成，下面介绍如何利用smart-doc工具来生成Dubbo的RPC内部接口文档。 dubbo文档集成 smart-doc本着使用简单的原则开发了maven插件和gradle，通过插件来降低smart-doc的集成难度和去除依赖侵入性。 您可以根据自己使用的依赖构建管理工具来选择相关的插件，下面以使用smart-doc-maven-plugin插件集成smart-doc生成dubbo为例。 当然集成smart-doc来生成Dubbo RPC接口文档你有两种可选方式： 使用smart-doc扫描dubbo api模块 使用smart-doc扫描dubbo provider模块 下面来看下集成方式。 添加插件 在你的dubbo api或者或者是dubbo provider模块中添加smart-doc-maven-plugin。当然你只需要选中一种方式即可 com.github.shalousun smart-doc-maven-plugin [最新版本] ./src/main/resources/smart-doc.json 测试 com.alibaba:fastjson com.alibaba:fastjson compile html 添加smart-doc所需配置文件 在你的Dubbo API或者或者是dubbo provider模块reources中添加smart-doc.json配置文件 { \"isStrict\": false, //是否开启严格模式 \"allInOne\": true, //是否将文档合并到一个文件中，一般推荐为true \"outPath\": \"D://md2\", //指定文档的输出路径 \"projectName\": \"smart-doc\",//配置自己的项目名称 \"rpcApiDependencies\":[{ // 项目开放的dubbo api接口模块依赖，配置后输出到文档方便使用者集成 \"artifactId\":\"SpringBoot2-Dubbo-Api\", \"groupId\":\"com.demo\", \"version\":\"1.0.0\" }], \"rpcConsumerConfig\":\"src/main/resources/consumer-example.conf\"//文档中添加dubbo consumer集成配置，用于方便集成方可以快速集成 } 关于smart-doc如果你生成文档需要更详细的配置请常看官方其它文档 rpcConsumerConfig： 如果下你想让dubbo consumer集成更加快速，你可以将集成配置示例consumer-example.conf中， smart-doc会将该示例直接输出到文档中。 dubbo: registry: protocol: zookeeper address: ${zookeeper.adrress} id: my-registry scan: base-packages: com.iflytek.demo.dubbo application: name: dubbo-consumer dubbo接口扫描 上面提到了smart-doc支持单独去扫描dubbo api或者dubbo provider。在 扫描原理是主要通过识别smart-doc官方自定义@dubbo注释tag或Dubbo官方的@service注解。 扫描dubbo api dubbo api通常都是很简洁的Dubbo接口定义，如果你需要让smart-doc扫描到Dubbo接口，那么需要加上@dubbo注释tag。示例如下： /** * 用户操作 * * @author yu 2019/4/22. * @author zhangsan 2019/4/22. * @version 1.0.0 * @dubbo */ public interface UserService { /** * 查询所有用户 * * @return */ List listOfUser(); /** * 根据用户id查询 * * @param userId * @return */ User getById(String userId); } 扫描dubbo provider 如果想通过dubbo provider生成RPC接口文档的情况，你不需要加任何的其他注释tag，smart-doc自动扫描@service注解完成。 /** * @author yu 2019/4/22. */ @Service public class UserServiceImpl implements UserService { private static Map userMap = new HashMap<>(); static { userMap.put(\"1\",new User() .setUid(UUIDUtil.getUuid32()) .setName(\"zhangsan\") .setAddress(\"四川成都\") ); } /** * 获取用户 * @param userId * @return */ @Override public User getById(String userId) { return userMap.get(userId); } /** * 获取用户 * @return */ @Override public List listOfUser() { return userMap.values().stream().collect(Collectors.toList()); } } 生成操作 直接通过mvc命令运行插件的文档生成命令或者在IDEA中直接单击插件的可视化命令即可。 运行rpc-html等就能生成Dubbo RPC文档 © All Rights Reserved            updated 2023-11-05 16:34:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"integrated/jax-rs.html":{"url":"integrated/jax-rs.html","title":"jax-rs","keywords":"","body":"标准Java REST API：JAX-RS简介 JAX-RS是标准的Java REST API，得到了业界的广泛支持和应用，其著名的开源实现就有很多， 包括Oracle的Jersey，RedHat的RestEasy，Apache的CXF和Wink，以及restlet等等。 另外，所有支持JavaEE 6.0以上规范的商用JavaEE应用服务器都对JAX-RS提供了支持。 因此，JAX-RS是一种已经非常成熟的解决方案，并且采用它没有任何所谓vendor lock-in的问题。 JAX-RS在网上的资料非常丰富，例如下面的入门教程： Oracle官方的tutorial：https://docs.oracle.com/javaee/7/tutorial/jaxrs001.htm IBM developerWorks中国站文章：http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/ 更多的资料请自行google或者百度一下。就学习JAX-RS来说，一般主要掌握其各种annotation的用法即可。 当前也有国外也有一些主流的Java Web框架使用JAX-RS规范，例如： 云原生时代的JAVA微服务框架Quarkus : https://quarkus.io/ Eclipse MicroProfile 是一个Java微服务开发的基础编程模型，它致力于定义企业Java微服务规范 当前已经发布了对Quarkus的支持。大多数的JAX-RS注解已经支持，欢迎正在使用JAR-RS的同学使用并提出issue JAX-RS支持配置 主要是在smart-doc.json配置文件中增加framework配置。 { \"serverUrl\": \"http://localhost:8080/\", \"outPath\": \"target/doc\", \"isStrict\": false, \"allInOne\": true, \"coverOld\": true, \"createDebugPage\": true, \"style\":\"xt256\", \"packageFilters\": \"\", \"projectName\": \"smart-doc-quarkus-example\", \"framework\": \"JAX-RS\" } 更多配置请参请查阅其它部分的文档了解。 © All Rights Reserved            updated 2023-11-19 09:48:44 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"plugins/maven.html":{"url":"plugins/maven.html","title":"maven","keywords":"","body":"Maven 从smart-doc 1.7.9开始官方提供了Maven插件，可以在项目中通过运行插件来直接生成文档。 环境要求 Maven 3.3.9+ JDK1.8+ 插件使用范围 在smart-doc-maven-plugin 1.0.2以前的版本，在多模块的Maven项目中使用插件存在着各种问题。 自smart-doc-maven-plugin 1.0.2插件开始，我们在插件上做了很多努力，不仅解决了插件在Maven多模块中存在的各种问题， 而且为smart-doc带来更强的源码加载能力。 在使用插件的情况下，smart-doc的文档分析能力增强的很多。 smart-doc-maven-plugin 1.0.8开始支持Dubbo RPC文档生成。 也建议使用旧版本smart-doc-maven-plugin的用户立即升级到最新版本。后续在使用smart-doc时推荐采用插件的方式。 使用插件后就不需要在项目的maven dependencies中添加smart-doc的依赖了，直接使用插件即可。如果需要保留原有单元测试，需要引用smart-doc的依赖。 使用参考如下： 添加插件 com.ly.smart-doc smart-doc-maven-plugin [最新版本] ./src/main/resources/smart-doc.json ${project.description} com.baomidou:mybatis-plus-extension com.baomidou:mybatis-plus-core org.springframework.data:spring-data-commons compile html 插件 configuration configFile 指定生成文档的使用的配置文件。相对路径时请用./开头，eg: ./src/main/resources/smart-doc.json projectName 指定项目名称，推荐使用动态参数，例如${project.description}。 2.3.4开始, 如果smart-doc.json中和此处都未设置projectName，插件自动设置为pom中的projectName excludes & includes 加载源码机制 smart-doc会自动分析依赖树加载所有依赖源码，不过这样会存在两个问题： 加载不需要的源码，影响文档构建效率 某些不需要的依赖加载不到时，会报错（smart-doc默认所有的依赖都是必须的） 依赖匹配规则 匹配单个依赖： groupId:artifactId 正则匹配多个依赖： groupId:.* includes 使用includes，按需加载依赖，减少不必要的依赖解析。 通常我们需要的依赖就除了几个常见的三方库，就是公司内部的二方库，和项目中的其他模块。 com.baomidou:mybatis-plus-extension com.baomidou:mybatis-plus-core org.springframework.data:spring-data-commons com.xxx:.* excludes 在运行插件时，遇到某些Class无法加载的情况，将该Class所在的依赖排除。 org.springframework.boot:spring-boot-mongodb excludes & includes 最佳实践 要使用include，加载需要的源码，如果不需要别的依赖，可以写项目自身的 groupId:artifactId 遇到报错后，使用excludes排除报错依赖 添加smart-doc生成文档的配置 在项目中添加创建一个smart-doc.json配置文件，插件读取这个配置来生成项目的文档， 这个配置内容实际上就是以前采用单元测试编写的ApiConfig转成json后的结果，因此关于配置项说明可以参考原来单元测试的配置。 最小配置单元： { \"outPath\": \"D://md2\" //指定文档的输出路径 } 详细配置请参考具体文档(定制化 | 配置项) 上面的json配置实例中只有\"outPath\"是必填项。其它的配置根据自身项目需要来配置。 注意： 对于老用户完全可以通过Fastjson或者是Gson库将ApiConfig转化成json配置。 运行插件生成文档 5.1 使用maven命令行 //生成html mvn -Dfile.encoding=UTF-8 smart-doc:html //生成markdown mvn -Dfile.encoding=UTF-8 smart-doc:markdown //生成adoc mvn -Dfile.encoding=UTF-8 smart-doc:adoc //生成postman json数据 mvn -Dfile.encoding=UTF-8 smart-doc:postman // 生成 Open Api 3.0+,Since smart-doc-maven-plugin 1.1.5 mvn -Dfile.encoding=UTF-8 smart-doc:openapi // 生成文档推送到Torna平台 mvn -Dfile.encoding=UTF-8 smart-doc:torna-rest // Apache Dubbo RPC文档 // Generate html mvn -Dfile.encoding=UTF-8 smart-doc:rpc-html // Generate markdown mvn -Dfile.encoding=UTF-8 smart-doc:rpc-markdown // Generate adoc mvn -Dfile.encoding=UTF-8 smart-doc:rpc-adoc // 生成dubbo接口文档推送到torna mvn -Dfile.encoding=UTF-8 smart-doc:torna-rpc 在使用mvn命令构建时如果想查看debug日志，debug日志也能够帮助你去分析smart-doc-maven插件的源码加载情况，可以加一个-X参数。例如： mvn -X -Dfile.encoding=UTF-8 smart-doc:html 注意： 尤其在window系统下，如果实际使用mvn命令行执行文档生成，可能会出现乱码，因此需要在执行时指定-Dfile.encoding=UTF-8。 查看maven的编码 # mvn -version Apache Maven 3.3.3 (7994120775791599e205a5524ec3e0dfe41d4a06; 2015-04-22T19:57:37+08:00) Maven home: D:\\ProgramFiles\\maven\\bin\\.. Java version: 1.8.0_191, vendor: Oracle Corporation Java home: D:\\ProgramFiles\\Java\\jdk1.8.0_191\\jre Default locale: zh_CN, platform encoding: GBK OS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\" 5.2 在IDEA中生成文档 插件源码 smart-doc的maven插件源代码 插件调试 在使用smart-doc-maven-plugin插件来构建生成API文档的过程中可能会出现一些错误问题。 如果一些复杂问题出现时仅仅是粗略的将错误信息放在提到issue中， 官方并不能根据这些简单的错误信息来解决问题，因为用户的使用环境和所写的代码都是我们无法模拟的。 因此我们希望使用smart-doc-maven-plugin的用户在报错时能够通过debug来获取到更详细的信息。 在提issue时添加详细的问题描述，这样也能帮助我们更加快速的修改问题。 下面将介绍如何来调试smart-doc-maven-plugin插件。 添加smart-doc依赖 因为smart-doc-maven-plugin最终是使用smart-doc来完成项目的源码分析和文档生成的， 通常情况下真正的调试的代码是smart-doc。但这个过程主要通过smart-doc-maven-plugin来排查。 com.ly.smart-doc smart-doc [最新版本] test 注意： 使用smart-doc的版本最好和插件依赖的smart-doc版本一致。 添加断点 添加断点如图所示 Debug模式运行构建目标 maven插件在idea中运行debug非常简单，操作如下图。 这样就可以直接进入断点了。 提示： 上面是通过插件去作为入口调试smart-doc的源码，如果你想调试插件本身的源码执行过程，则将插件的依赖添加到项目依赖中,如下： com.ly.smart-doc smart-doc-maven-plugin 【maven仓库最新版本】 然后通过上面 的类似步骤调试smart-doc-maven-plugin的源码 © All Rights Reserved            updated 2023-11-05 16:34:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"plugins/gradle.html":{"url":"plugins/gradle.html","title":"gradle","keywords":"","body":"gradle Introduce smart-doc-gradle-plugin是smart-doc官方团队开发的gradle插件，该插件从smart-doc 1.8.6版本开始提供， 使用smart-doc-gradle-plugin更方便用户集成到自己的项目中，集成也更加轻量，你不再需要在项目中编写单元测试来 启动smart-doc扫描代码分析生成接口文档。可以直接运行gradle命令 或者是IDEA中点击smart-doc-gradle-plugin预设好的task即可生成接口文档。 Getting started Add plugin Gradle中添加插件有两种方式: 一种是DSL，高版本Gradle推荐直接使用DSL，另一种是legacy。 Using the plugins DSL Using the plugins DSL: plugins { id \"com.ly.smart-doc\" version \"[最新版本]\" } Using legacy plugin application Using legacy plugin application: buildscript { repositories { maven { url 'https://maven.aliyun.com/repository/public' } maven { url 'https://maven.aliyun.com/repository/gradle-plugin' } maven { url = uri(\"https://plugins.gradle.org/m2/\") } mavenCentral() } dependencies { classpath 'com.ly.smart-doc:smart-doc-gradle-plugin:[最新版本]' } } apply(plugin = \"com.ly.smart-doc\") buildscript配置添加到build.gradle的顶部 。 Plugin options 使用smart-doc插件还需要在build.gradle添加一些常见本身的配置 Option Default value Required Description configFile src/main/resources/default.json true 插件配置文件 exclude 无 false 排除一些无法自动下载的java lib sources,例如:exclude 'org.springframework.boot:spring-boot-starter-tomcat' include 无 false 让插件自定下载指定的java lib sources,例如:include 'org.springframework.boot:spring-boot-starter-tomcat' Example setting of options: smartdoc { configFile = file(\"src/main/resources/smart-doc.json\") // exclude example // exclude artifact exclude 'org.springframework.boot:spring-boot-starter-tomcat' // exclude artifact use pattern exclude 'org.springframework.boot.*' // 你可以使用include配置来让插件自动加载指定依赖的source. include 'org.springframework.boot:spring-boot-starter-tomcat' } 对于多模块的gradle，把smart-doc插件相关配置放到根目录build.gradle的subprojects中。 subprojects{ apply plugin: 'com.ly.smart-doc' smartdoc { // configFile = file(\"src/main/resources/smart-doc.json\") // exclude artifact exclude 'org.springframework.boot:xx' exclude 'org.springframework.boot:ddd' // 你可以使用include配置来让插件自动加载指定依赖的source. include 'org.springframework.boot:spring-boot-starter-tomcat' } } 多模块smart-doc的实战demo参考 https://gitee.com/smart-doc-team/smart-doc-gradle-plugin-demo 多模块和单模块项目是有区别，多模块不从根目录使用命令构建可能会导致模块间源代码加载失败，生成文档出现各种问题。 Create a json config 在自己的项目中创建一个json配置文件，如果是多个模块则放到需要生成文档的模块中，smart-doc-gradle-plugin插件会根据这个配置生成项目的接口文档。 例如在项目中创建/src/main/resources/smart-doc.json。配置内容参考如下。 最小配置单元: { \"outPath\": \"D://md2\" //指定文档的输出路径 相对路径时请写 ./ 不要写 / eg:./src/main/resources/static/doc } Generated document Use Gradle command //生成html gradle smartDocRestHtml //生成markdown gradle smartDocRestMarkdown //生成adoc gradle smartDocRestAdoc //生成postmanjson数据 gradle smartDocPostman //生成Open Api 3.0 +规范的json文档,since smart-doc-gradle-plugin 1.1.4 gradle smartDocOpenApi //生成rest接口文档并推送到Torna平台,@since 2.0.9 gradle tornaRest // Apache Dubbo Rpc生成 // Generate html gradle smartDocRpcHtml // Generate markdown gradle smartDocRpcMarkdown // Generate adoc gradle smartDocRpcAdoc // 推送rpc接口到torna中 gradle tornaRpc Use IDEA 当你使用Idea时，可以通过Gradle Helper插件选择生成何种文档。 插件源码 https://github.com/TongchengOpenSource/smart-doc-gradle-plugin smart-doc官方的Gradle插件开发正在进行中，当前完成了插件的主体结构，在优化测试中，请耐心等待发布。 插件调试 smart-doc-gradle-plugin插件依赖于smart-doc来完成文件的解析，smart-doc-gradle-plugin主要是为了用户更加快速简易的 将smart-doc集成到项目 中生成API文档，同时smart-doc-gradle-plugin插件也是给smart-doc进行赋能，实现自动分析一些source jar的源码的路径， 然后将路径赋予smart-doc方便更好的基于源码分析。 但是smart-doc面对着很多的用户，各式各样的代码我们在开发的时候并不能完全考虑到。有的代码甚至作者也从未写过。 因此出现一些不明原因时通常需要用户自己进行调试。本节将介绍如何在自己的项目中通过smart-doc-gradle-plugin来调试smart-doc底层的解析。 添加smart-doc依赖 添加smart-doc依赖主要是方便直接查看到源码调试。未发生错误，不需要调试事并不需要在自己的项目中添加smart-doc依赖。 dependencies { testCompile 'com.ly.smart-doc:smart-doc:【最新版本】' } 找到smart-doc源码打上断点。操作如下图： 命令行终端设置debug模式 Gradle插件的调试并不像调试JAVA程序和Maven插件那么简单。在IDEA上直接点击debug启动相关操作就可以直接调试了。 需要实现在命令行设置调试模式。操作如下图： 图中主要是打开命令行终端指定让smart-doc-gradle-plugin的某一个task使用debug模式运行, 如上图所示指定构建html文档的task来开启debug模式，命令示例如下： gradlew smartDocRestHtml -Dorg.gradle.daemon=false -Dorg.gradle.debug=true 如果执行上面命令出现下面的错误 错误: 找不到或无法加载主类 org.gradle.wrapper.GradleWrapperMain 则请先执行下面一条命令让Gradle自动下载设置好GradleWrapper,当然网络问题自行处理。 gradle wrapper 添加一个远程调试监听 点击 Edit Configurations 点开左边的“+”号，点击“Remote” 执行调试 完成上面的操作后即可用debug调试进入插件和smart-doc了，然后查看smart-doc的执行情况。操作如下图 © All Rights Reserved            updated 2023-11-05 16:34:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"faq/question.html":{"url":"faq/question.html","title":"常见问题","keywords":"","body":"Smart-Doc使用问题集 关于Q&A，请按下面的流程： 在Wiki中有的内容，请花时间看文档，不要提Issue。 重复的Issue会被删除，请先在Issues中搜索你的问题，确认没有后再提Issue。 我碰到个错误，确定是Bug，请按Issue模版提Bug or PR。 咨询和讨论请来微信群，在群里交流。 为什么写这个文档 我们整理该文档的目的是减少萌新和菜鸟的一些疑惑，如有问题请仔细查看。当然看在我们辛苦整理文档的份上， 如果你喜欢smart-doc，也请推荐给你的同事或者朋友，好的东西要分享给大家。 smart-doc测试用例反馈 有些bug出现了，简单的issue中添加粘贴几行代码反馈的问题官方很难复现，这种情况下需要提供一个能够复现问题的代码。 下面来说下怎么给官方提供用例。 单模块测试用例 如果你是单模块中就能复现的问题，则提用例的步骤如下： fork smart-doc-example-cn项目到个人仓库中； 修改fork的代码添加测试用例，然后项目github上会有一个【Sync fork】的地方，选择给我们提pr即可，后面官方也会合并的测试用例进行问题的测试。 多模块项目测试用例反馈 如果你是在多模块中才能复现的问题，则提用例的步骤如下： fork spring-boot-maven-multiple-module项目到个人仓库中； 修改fork的代码添加测试用例，然后项目gitee上会有一个【Pull Request】的地方，选择给我们提pr即可，后面官方也会合并的测试用例进行问题的测试。 FAQ smart-doc 如何提升smart-doc生成文档的速度？ smart-doc maven或者是gradle插件在默认情况下会自动分析项目的pom或者gradle提取依赖关系， 然后自动去下载依赖的源码并加载到内存中，如果被加载的类越多，在完成源代码加载进入解析阶段就会需要执行扫描很多不必要的类 过滤。因此提升smart-doc生成文档速度最重要的就是让smart-doc的插件少加载代码。通常对于一个项目来说， 和生成文档api层直接关联的非常少，这些都是不必要的加载。 提升速度最直接的方式就是在插件中配置：include或者exclude 。例如： com.ly.smart-doc smart-doc-maven-plugin [最新版本] ./src/main/resources/smart-doc.json com.alibaba:.* 关键插件的详情配置，插件文档插件使用部分去了解细节。 smart-doc和swagger的区别 尤其是新手，一定要了解smart-doc和swagger的本质区别： smart-doc主要是基于源代码和JAVADOC标注注释来生成文档，是在开发期或者是项目的编译期执行生成文档， 在最终在打包运行的jar内你是找不到smart-doc的依赖的，因此是完全不侵入项目运行期的， 也就不能像swagger一样项目启动时更新文档。 swagger主要原理是利用JAVA的注解和反射机制去生成文档。如果项目文档要比较清晰就必须使用大量的注解。 注解和业务代码强绑定，当然最终构建产出的部署包里也就必须包含swagger的依赖了。也因为swagger是利用反射 来生成文档，所以可以做到项目启动时更新文档。 这里可能一些刚入行的同学有些疑问，经常会问为什么我写了注释， 跨模块或者跨项目引用过来smart-doc就获取不到注释了， 请记住编译后的代码不存在注释，包括泛型也不存在。弄清楚原理，不要闹笑话！ 当然怎么发布源码和加载源码，官方文档都有介绍，请自己把官方文档都看一遍。官方也相关的demo。 Smart-doc组件最新版本是多少？ 对于开源软件的版本获取，有好几种方式可以查到： Maven Repository：许多人第一选择查询的站点，对于一些不是经常被搜索的开源软件并不能直接通过artifactId搜索到， 原因是这取决与这个Java开发组件的搜索率以及这个站点的搜索算法，一般都是非常流行的才能直接搜索到。 如果你搜索不到可以换成group去搜索。 Maven Central Repository：这才是正儿八经发布公有组件的仓库，大部分JAVA 开源都是从这个站点发布后被其它仓库同步过去，因此这里一定能搜索到。 阿里云Maven仓库：国内阿里云提供的仓库，也是从Maven Central同步过来。 这里也可以搜索到。 项目仓库首页徽标： 你打开smart-doc或者是smart-doc-maven-plugin以及smart-doc-gradle插件代码仓库的首页都能看到 最新版的版本徽标。这也是大多数标准开源项目的做法。 项目的tag列表： 一般项目开源项目发布版本的时候作者都会给代码打上tag。即便是作者不把tag做release写release日志。 但是这个也是可以参考的。 只要你掌握了上面几种方法什么开源软件版本查找都难不倒你。 你GET到了吗？GET到了那就快去https://github.com/smart-doc-group/smart-doc 给我们一键三连吧！ 注释怎么提取不到啊？ 这个往往是一些萌新提出的问题。smart-doc的原理是使用源代码中的注释和泛型来分析生成文档。 因此使用smart-doc时要明白几个基础知识点： JAVA注释只存在于源代码中，一旦代码经过编译后注释就被编译器擦除了，不信你自己解压一个编译过的jar包看看里面的class还有没有注释。 JAVA的泛型也是后来才添加的，也并不是从一开始底层就支持泛型的，因此源代码编译后泛型也会被擦除。 明白了上面原理后，你就知道为什么smart-doc官方要求你如果把代码作为公用库被其他项目使用是要发布一个resource jar的原因了。 当然你可以能存在两种原因加载不到源代码： 插件配置错误 发布了源代码jar到私服，但是使用maven或者gradle插件时胡乱拷贝官方文档中的配置，不根据自己的项目情况去正确配置include导致代码无法加载。 因此请建议回头再看看插件部分配置文档，多注意加粗的字体介绍。不易轻易问简单问题被打脸。 Maven多模块项目无法加载公用模块中的注释：首先检查自己项目结构是否符合多模块的做法。smart-doc插件依赖底层maven api来处理， 如果项目做得不好可能就无法自动去追溯你工程的依赖结构。 建议去参考官方的多模块demo。 当然官方的插件也不是万能的，毕竟很多奇怪的工程搭建官方人员也没见识过，因此如果有问题始终无法解决， 那请给官方提供一个完整模拟你项目结构的工程，并不要求写什么代码，每个模块写一个测试类即可。 不要觉得你能随便就能描述清楚，记住show me your code. 如果你使用Java main或者是单元测试等硬编码来启动smart-doc也可能导致注释提取失败。硬编码模式 仅仅适合单模块项目，所有代码都来自一个独模块中。 为什么提取的注释混乱啊？ 提取的注释显示一团糟，显示不正常。这种通常就是mac用户的锅，mac中使用idea时使用了\\r作为换行符。 解决方案是先让团队统一在idea上使用unix换行符， 然后是写脚本把\\r提供掉。脚本就自己搞定吧。 这个问题很多同学会以为我的idea配置换行符是正确，最后还是乱了， 文件的换行规则取决于最先提交这个文件的同学是怎么设置的，如果也开始就错了，后来添加进去的换行也是不对的。 为什么我的泛型嵌套对象无法分析啊？ 遇到泛型分析问题，请先升级到2.7.2+的版本。2.7.2开始后解析泛型不再强行要求有源代码 如果你有该疑问，那么你应该先思考下几点问题： smart-doc这么简单的问题都没解决，它为何会有这么多用户，并且这些用户中也不缺乏国内大厂企业； 一个很多基础功能都不具备的开源软件变得流行是不符合逻辑的。 真正聪明的人，都是懂得分析情况去反思自己。 言归正题，官方的demo提供了很多复杂的泛型分析例子，并且生成文档良好，但是在你自己项目中在泛型中申明了具体类型，smart-doc却没有分析正确。 只要原因有两点： smart-doc没有加载到你的源码(来自项目外的代码或者是本模块外的代码)，JAVA在编译后泛型变成了Object类型。如果smart-doc没有读取到源代码， 只是从class中通过反射获取字段类型时就无法知道那是泛型，最终无法正确分析。没获取到加载到源码通常有一个很明显的显示，实体的字段注释全部为No comments found.； 你使用了不太规范的泛型定义，例如使用多字母定义泛型，如下使用BR作为泛型定义。 public abstract class BaseResult implements Serializable { /** * 是否成功 * */ private boolean success = false; /** * 错误提示(成功succeed) */ private String message; /** * 成功返回的数据 */ private BR data; } 解决方式 如果你使用smart-doc单元测试方式来生成文档，那么在单元测试代码中设置外部源代码路径。让smart-doc加载到源代码来分析。当然官方并不推荐使用单元测试，在多人开发的团队每个人电脑路径不一致，在规范的公司代码的打包通常使用自动化构建工具完成，设置代码路径不好维护。单元测试只适合于个人开发项目使用。 如果你使用的smart-doc-maven-plugin或者是smart-doc-gradle-plugin。对于无法访问国外中央仓库下载第三方源码库的同学，请在Maven中配置国内的阿里云Maven仓库，即便你是使用自己公司的Nexus那么也请找相关管理人员给Nexus配置阿里云的仓库代码。 最终目的是确保让插件通过你Maven环境指定的库能够加载到第三方库的source源码jar包。有源代码生成的文档效果就会更好。 如果你是像上面一样使用了不太规范的泛型定义，分析结果也会不理想，那么请你按照[《smart-doc最佳实践》]（https://smart-doc-group.github.io/#/zh-cn/start/bestPractice）中的泛型定义规范了修改你的泛型定义。 注意你不要祈求官方会去修改支持多字母泛型定义，smart-doc在为大家带来方便的同时，规范一直是我们坚守的信念。 多模块 多模块怎么构建文档啊？ 在单模块项目中，例如在Idea中使用smart-doc插件可以很容易的在Idea界面上去找到maven的工具视图并找到 smart-doc插件来生成文档。但是在多模块项目中，这个就不行了，因为smart-doc的插件直接使用的是maven底层的 API，这种使用底层API的好处是你可以在构建工具中直接出发smart-doc插件去生成文档。 整个过程完成和使用mvn命令来构建多模是一样的，gradle插件也类似。由于官方多模块demo 都已经这过程做了说明因此你可以去看官方demo的README文档。 当然这里也介绍一个构建编排的利器给你Makefile： 什么是Makefile: 很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作， 但是如果你或多或少的看过一些开源的C、C++或者是GO程序，基本都能看到他的身影。Makefile就像一个Shell脚本一样， 我们可以用它来执行一系列的操作命令。 Makefile带来的好处: 好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。 看来上面关于Makefile的描述后我想你已经有点了解了，但是为什么我要给你推荐它? IDEA中有Makefile的插件来支持你像点击IDEA中的maven工具一样，一次编写好构建命令后可以直接去点击Makefile中的命令执行。 无需在手动输入。 那如何在Windows上支持Makefile呢？ Window环境下先安装MinGW，MinGW安装后有在安装目录的bin中有一个make.exe， 可以在Path系统环境变量中添加MinGW。添加成功后即可。 Idea中安装Makefile Support插件 安装好环境之后即可在Idea中打开Makefile，然后直接选中具体的构建指令运行了。 当然怎么去安装和配置，请自行去百度吧，官方已经给出思路了。百度安装配置好就可以使用了。 有Makefile编写例子吗？ Makefile参考 在多模块中构建使用smart-doc为什么会依赖报错？ smart-doc在这几年的发展中，随着使用的用户越来越多，时不时就会有同学问这个问题。 Idea这样的工具让开发编译打包maven或者gradle项目变得非常简单。但是也带来另外的问题， 那就是许多刚入行的开发者已经不知道怎么使用最基础的mvn命令来构建项目。 尤其是对于多模块的项目要怎么使用mvn命令来构建， 另外一个原因也是很多同学也没有什么机会接触到像jenkins这样的构建工具。 因此在多模块中使用smart-doc中出现依赖报错后就不知道具体的原因和处理方式了。 碰到这个问题。我建议首先去看官方文档中的多模块中使用的介绍文档。 另一方面是用命令行了解下mvn纯命令的构建，尤其是作为新入行的同学， 如果未来想成为小组的技术负责人或者是团队技术负责人，都需要去了解各种DevOps工具。 使用这些DevOps工具时一定要知道怎么利用各种mvn命令去构建自己的项目完成上线。 smart-doc如何做多环境配置？ 在成熟的开发团队中，通常会有：研发、测试、预发、生产四大部署环境，即便是很小的公司，也有开发和线上环境。 不同的环境环境通常会有下面的一些区别： 服务器地址不相同； 请求头设置不同； 鉴权参数这些不同。 过去时不时的有人问smart-doc怎么支持多环境，其实一个配置文件把多个环境的都配置进去， 但是这个会比较难，smart-doc首先要知道你当前构建针对的是什么环境，然后还要去做配置解析匹配。 多个环境配置混乱在了一起，因此smart-doc官方一直不提供这种配置。对于有多环境文档配置需求的同学， 我们建议你参照SpringBoot的application.yml多环境配置。 例如针对开发环境配置一个smart-doc-dev.json， 针对测试环境配置一个smart-doc-test.json。然后使用在maven构建的项目里配置profile来做构建环境区分。 针对不同的环境让插件去使用不同smart-doc配置文件，这就可以完美解决多环境配置了。 即便是使用mvn命令行，我们也很容易利用maven命令的-P操作来指定构建环境。 可以参考下面的文档做学习变通配置： Spring boot使用Maven Profile配合Spring Profile进行多环境配置和打包 插件 项目无法加载smart-doc的插件 错误信息如下： No plugin found for prefix 'smart-doc' in the current project and in the plugin groups [org.apache.maven.plugins, org.codehaus.mojo] available from the repositories 这个问题其实和smart-doc没有任何关系，但是一些对maven不是很懂(只会简单使用)的同学会误认为是smart-doc的插件有问题。 实际上这个是因为在项目中添加了smart-doc的maven插件后，自己的网络有些问题，导致并没有从maven仓库中下载到官方的插件。 其他 内存溢出了怎么解决？ 在使用smart-doc相关maven或者是gradle插件生成文档时，许多同学常常碰到堆内存溢出的问题。 问题原因： 插件默认会自动分析依赖，然后去加载依赖对应的源代码，如果项目依赖的东西涉及很多就可能产生溢出。 主要这里依赖就包括了项目的整个依赖树了。 解决办法： 配置maven或者gradle插件。最好指定加载生成文档所需要的依赖，通常生成API文档仅需要加载一些model类模块。 不要让插件给你做全自动加载。 还有一点是不要把IDEA的运行JAVA的内存配置过小。这可能也会导致你在IEAD中启动smart-doc插件 来生成文档过程中出现内存溢出。 关于插件的配置请在本文档中查看各插件的详细配置项，然后按照说明来配置。 如何发布公共库源码 在需要发布的公共库pom.xml文件中添加maven-source-plugin插件 org.apache.maven.plugins maven-source-plugin 3.2.1 package jar-no-fork 这样发布的时候就会生成一个[your jar name]-sources.jar的源码包，这个包也会一起发布到私有仓库。 发布成功后smart-doc的maven或者gradle插件可以根据依赖自定下载jar对应xx.sources.jar载入源码进行解析。 如果还是不清楚可以直接参考smart-doc源码的pom.xml配置。 注意： 经测试验证，如果只是通过install到本地，即便是指定了sources也无法读取到源码，只有将公用的模块deploy到nexus这样的私服上才能正常使用。 如何像swagger一样访问文档？ 访问文档做下面两步操作： 修改文档输出路径： 将html指定生成到项目的src/main/resources/static/doc下。 修改Spring Boot配置： 设置spring.resources.add-mappings=true 如果版本比较高则改配置项改成spring.web.resources.add-mappings=true。 当然不想让别人看到文档设置成false即可。 当然官方还是推荐你采用企业级的API文档管理系统Torna，前端测试对接也不用满山找文档和要链接，只要分配好权限， 大家都可以直接在Torna平台统一看到文档。这就好比微服化开发中的配置中心一样，分散总是不好管理。Torna也是Smart-doc官方布道开发的产品，和smart-doc可以很好的整合使用。 Yapi这些过去的开源产品，目前已经不怎么更新维护，也不像Torna一样拥有像smart-doc这样的搞解析力工具支持， 不要犹豫，选Torna就对了，选开源产品一定要看更新维护活跃度和社区活跃度。 示例中$ref是什么意思？ smart-doc提供了强大的分析结构分析能力，包括能够处理代码中的环形引用。但是一般环形引用的对象生成的json中会包含下面的文本端。 \"$ref\":\"...\" 如果出现上面格式的文本端，一般说明后台结构存在递归嵌套，这个标识自引用或者进入下一次重负递归。 could not match input？ Exception in thread \"main\" java.lang.Error: Error: could not match input at com.thoughtworks.qdox.parser.impl.JFlexLexer.zzScanError(JFlexLexer.java:1984) at com.thoughtworks.qdox.parser.impl.JFlexLexer.yylex(JFlexLexer.java:3328) 在2.3.3开始smart-doc升级了qdox版本，这个qdox版本支持record特性，但是升级后也出现一个问题。 就是qdox在解析一些版本比较老的jar包源码的时候出出现问题，这些老版本的代码中通常包含一些奇怪的特殊字符。 如果你在使用中遇到该错误，建议在使用smart-doc的maven或者是gradle插件的时候明确通过插件的include配置项 来加载必要的源码。避免插件自动加载了一些和API文档生成无关的旧依赖，同时也可以显著提升生成文档的速度。 打印上面错误： 如果使用maven插件，你可以试用mvn -X参数让插件打印debug，然后查看是到加载那个resource出现了错误，例如： mvn -X -Dfile.encoding=UTF-8 smart-doc:html 通过添加-X然后通过命令行去让smart-doc生成文档时，插件会自动打印debug信息。然后从控制台日志中搜索smart-doc loaded jar source:, 最后一个smart-doc loaded jar source:日志后面加载的jar就有问题的jar。然后自己去查看插件的配置把这个jar包排除掉即可。 当然找到这些报错的包后也建议给官方提报错的依赖，我们可以在后续的升级当中自动排除这些导致错误的包。 syntax error？ 在使用smart-doc时有同学经常会看到[WARNING] syntax error的告警信息输出，例如： [WARNING] syntax error @[17,20] in file:/D:/MyConfiguration/USER/IdeaProjects/smart-doc-example-cn/src/main/java/com/power/doc/model/PersonCreateDto.java 如果错误是来自第三方依赖的代码，基本不用管，因为生成文档时很少会需要用到第三方库的类。 当错误来自我们自身的业务代码时就需要关心下了，因为会影响文档的生成。这个通常是我们代码中使用到了java的保留关键字，例如方法的参数名、类的字段名。 可以根据告警信息去查看具体带代码行和字符起是位置 ，例如上面的提示是因为代码17行定义了。 private String record; 然后第20个字符r，这就是字段触发了jdk 14的保留关键字。代码行比较长的话可以用复制代码去打印。查看字符。 String code = \" private String record\"; char[] arr = code.toCharArray(); for(int i=0;i record目前已经是java的关键字，如果是record导致的问题，建议不要再自己的业务代码中使用record，这会影响后面升级到jdk 17. 如果从地方依赖导致的错误，建议根据报错代码的包直接通过插件的exclude配置项把报错的依赖排除掉。 © All Rights Reserved            updated 2023-11-05 16:34:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"community/idea.html":{"url":"community/idea.html","title":"理念","keywords":"","body":"理念 smart-doc适用设计先行的开发吗？ 一些老派的程序员或者所谓有多年经验的架构师觉得，smart-doc这种基于代码扫描工具对于设计先行的开发模式并没有什么作用。 真的是这样的吗？我们来看看吧。 设计先行模式 由比较有经验的人编写设计文档和接口协议。 完成设计后主要由业务开发工程师根据设计文档开发业务逻辑。 架构师也可以像国外一些架构师一样，直接定义好程序的接口框架，然后交付给业务工程师填充业务代码。 设计先行通常在成熟的开发团队中。在代码先行模式下，接口协议虽然在设计阶段都已经定义好。但是smart-doc仍然很有用。 设计的好的接口协议后期的持续更新遗漏，仍然是个问题，人性本是懒惰的。smart-doc能够保持文档和代码的一致性。 一个新成员进入团队看代码，html的文档明面比word写的更方便跟踪。新成员完全可以直接上手打开debug文档页面调试熟悉业务。 smart-doc由于采用源码分析，对代码的标准度要求高于其他工具，使用这个工具直接就能统一团队风格。 还可以基于smart-doc定制开发，将文档输送到yapi这样类似的接口文档管理中。 目前国内主流的设计先行的文档方式，主要就是word或者是markdown。word的翻页对接口展示很不友好。 代码先行 代码先行的这种模式，利用smart-doc天然就可以一边写代码一边出接口文档。然后利用smart-doc对代码的规范要求严格度。 完全可以保证团队代码风格不会出现很大差异。 代码先行在很多团队是有弊端的，代码先行特别是对大型系统，对代码编写者能力要求很高。 代码和业务的结合能力需要非常强，能够考虑到扩展和业务边界。代码先行这种，也可以走另外一种路线， 团队的架构师直接搭建好项目框架后，定义好接口框架代码，填充业务逻辑部分全部空出来。有了接口，smart-doc已经可以扫描生成接口文档了 总结 总之，使用文档工具和团队采用哪种模式并没有半点关系。工具是为了在某些方面去帮助团队更好的完成工作或者是提高效率。 作为技术人员也要向前看，总会有新的技术、新的框架、新的工具出来去解决过去的一些问题。对新事物持有好奇心也是一种人生态度。 我是菜鸟能参与开源吗？ 开源软件最重要的指标并非是技术，社区的活跃度和代码贡献者数量才是衡量开源软件能够持续发展的指标。 因此只要你有时间和愿意参与贡献，smart-doc的作者基本都指导你怎么去修改issue。 smart-doc的核心维护者中也有同学是从在校生开始加入开发，并在后面成功拿到国内某大厂offer的。 因此我们非常欢迎愿意参与开源的同学加入，即便你是菜鸟都不用担心。 smart-doc当前已经被国内许多一二线大厂所采用，未来只会更多。参与开源对菜鸟和萌新的帮助都是蛮大的。 © All Rights Reserved            updated 2023-11-05 16:34:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"community/developer.html":{"url":"community/developer.html","title":"开发者","keywords":"","body":"社区角色 smart-doc社区包含Maintainer、Committer、Contributor等角色，每种角色的标准定义如下。 Maintainer 对smart-doc项目演进和发展做出显著贡献的个人。 成为 Maintainer 的标准： 完成多个关键核心功能模块设计与开发，是项目的核心开发人员； 持续的投入和激情，能够积极参与社区、官网、Issue、Pull Request(PR) 、Discussion 等项目相关事项的维护； 在社区中具有非常好的影响力，能够代表社区对外做一些分享。 成为Maintainer，您也将获得如下权利： 具有Smart-doc GitHub 仓库管理权限。 参与新晋Committer或Maintainer的提名及投票。 Committer 是对smart-doc社区某些特定领域做出突出贡献的人 成为Committer的标准： 能够长时间地并持续性地贡献Issue、PR 代码、测试用例、文档、案例)，社区贡献10个及以上高质量PR； 参与重要 Feature 的讨论、设计、开发、测试； 参与 Code Review。 成为Committer，您也将获得如下权利： 具有smart-doc GitHub仓库write权限。 参与smart-doc演进、发展的讨论，及核心模块设计评审等。 成为Committer，您将获得的奖励： 社区官网对Committer做展示。 社区文化衫或其他礼品奖励。 Contributor 是对smart-doc项目有贡献的个人。 成为Contributor的标准： 提交过PR并被合并，包括不限于文档、代码、案例等； 在smart-doc开源社区参与相关问题讨论，并能积极回复。 如何成为Contributor及Committer 只要您对smart-doc项目有兴趣，每个人都可以成为smart-doc项目的Contributor。 您可以从贡献文档开始参与社区贡献，并逐步参与代码的贡献。 如果您成为了smart-doc Contributor并且持续地做出贡献，达到了Committer的要求，我们将邀请您成为smart-doc Committer. smart-doc开发团队 感谢所有开发者对社区的贡献！我们会定期将所有贡献者的名字进行展示，当然也可以自己提交 PR 添加。 注：排名不分先后。如有遗漏，请提交 PR 添加。 PMC(项目管理委员会，Project Management Committee) Yu Sun(@shalousun) Committer 社区目前处理迁移建设中，等待社区文档完善后评审。 Contributor https://github.com/TongchengOpenSource/smart-doc/graphs/contributors © All Rights Reserved            updated 2023-11-05 16:34:48 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"community/contributing.html":{"url":"community/contributing.html","title":"如何共建","keywords":"","body":"欢迎来到smart-doc社区！感谢您为smart-doc贡献代码、文档及案例！ smart-doc自2018年开源以来，受到社区很多小伙伴的关注。 衷心地希望越来越多的社区同学能参与到smart-doc项目中来， 我们一起把smart-doc做好！ 如何贡献？ 如果您想为smart-doc 做出贡献，可以按照以下步骤进行： 1、在GitHub上Fork smart-doc的代码库到您的个人仓库中。 2、Clone您fork的项目到本地仓库，创建其他分支以进行修改。 3、在本地环境中运行smart-doc，并确认所做的改动是否生效。可参考 快速开始 了解如何启动smart-doc并生成API文档。 4、完成修改后，推送提交并提交Pull Request给smart-doc的主仓库。请参考Pull Request流程 来提交合并请求。 5、等待社区Committer审核并合并您的Pull Request。 6、如果合并成功，恭喜您已经成功做出了贡献！ 注意的事项 在为smart-doc 提交贡献时，请注意以下事项： 如果您想添加新功能或者功能升级，请先开Issue讨论。 为了方便作者审核代码，建议每个Pull Request只提交单一问题的修复或者功能添加，避免大规模变更。 smart-doc作为一个为全球开发者服务的工具，提交代码时请使用英文注释，也是方便社区更好的做国际化推广。 请遵守代码风格约定，确保代码可读性和易维护性。 请确保所有提交的代码都有单元测试覆盖，以确保代码质量。 如有必要，更新相应的文档以反映您的更改。 最后，我们欢迎任何形式的贡献，包括但不限于代码、文档、Issue 提出等 Code review 所有的代码都需要经过Committer进行review。以下是我们推荐的一些原则： 可读性：所有提交请遵循良好的代码规范、文档规范。 优雅性：代码简练、复用度高，有着完善的设计。 测试：对于普通的方法在smart-doc上添加单元测试，对于用户接口代码请在smart-doc-example-cn 添加测试用例并完成提交测试验证。 案例分享 我们非常欢迎您分享任何关于smart-doc的使用案例。欢迎大家投稿，分享smart-doc的使用案例。 对于优秀的案例分享者，社区也会后续也会给予一些奖励。 参与社区讨论 如果您在使用smart-doc中遇到任何问题，欢迎到Discussions进行交流互动。 也欢迎在这里帮助其他使用者解答一些使用中的问题。 Discussion分类： Announcements：smart-doc官方公告。 Help：使用smart-doc中遇到问题，想在社区寻求帮助。 Ideas：关于smart-doc的一些想法，欢迎随时交流。 Show and tell：可以在这里展示任何跟smart-doc相关的工作，例如一些工具、案例等。 © All Rights Reserved            updated 2023-11-09 08:54:16 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"community/pull-request-process.html":{"url":"community/pull-request-process.html","title":"贡献流程","keywords":"","body":"pr贡献流程 开源指南 1. 从上游仓库同步（sync fork） Github 文档：syncing-a-fork 为了防止上游仓库的更改导致冲突，在pr之前要先sync frok, 解决冲突（尽量将冲突在本地解决）。 2. 从远程仓库同步 && 本地解决冲突 在本地使用git pull命令从远程仓库同步代码 如果没有冲突，那太好了。如果存在冲突，请参考 about-merge-conflicts解决 3. 提交commit && 推送到远程仓库 一个 pull request 中只能一个commit。如果有多个commit，使用rabse命令合并commit 每个commit都要在CHANGELOG中添加对应的修改记录。 git push 或则 git push -f(合并了远程commit添加 -f)推送commit到远程仓库 3. 创建 pull request 创建 pull request 认真填写title和comment。title简单描述你的意图，comment中详细描述过程。可以参考已关闭的pr)。 处理review。如果你的 pull request 很完美，会直接被社区采纳。如果社区review发现问题，会有评论，我们可以直接讨论，最后解决问题了，要点击 Resolve conversation。 注意：如果解决问题期间出现了多个commit，我们要使用rebase命令合并commit! © All Rights Reserved            updated 2023-11-09 08:52:13 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}